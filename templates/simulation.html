{% extends "base.html" %}

{% block title %}ä»¿çœŸè¯„ä¼° - æ— äººæœºé›†ç¾¤åŠ¨æ€ä»»åŠ¡åˆ†é…ä»¿çœŸå¹³å°{% endblock %}

{% block page_title %}ä»¿çœŸè¯„ä¼°{% endblock %}

{% block content %}
<!-- Leaflet.js CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin="" />

<div class="simulation-container">
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <div class="panel-header">
            <h3><i class="fas fa-cogs"></i> ä»¿çœŸæ§åˆ¶</h3>
        </div>
        <div class="panel-content">
            <!-- åœºæ™¯é€‰æ‹©åŒºåŸŸ -->
            <div class="control-group scenario-selection">
                <label>é€‰æ‹©åœºæ™¯ï¼š</label>
                <select id="scenarioSelect" class="scenario-select">
                    <option value="">è¯·é€‰æ‹©åœºæ™¯...</option>
                </select>
                <button class="btn btn-info btn-sm" id="loadScenario">åŠ è½½åœºæ™¯</button>
            </div>

            <div class="model-select-block">
                <div class="model-select-header">
                    <span><i class="fas fa-robot"></i> æ¨¡å‹é€‰æ‹©</span>
                    <span class="required-flag">ä»¿çœŸå¿…é€‰ï¼šç›®æ ‡åˆ†é… + ç«åŠ›åˆ†é…</span>
                </div>
                <div class="model-select-grid">
                    <div class="model-select-item">
                        <label>ç›®æ ‡åˆ†é…æ¨¡å‹ï¼š</label>
                        <select id="targetModelSelect" class="model-select">
                            <option value="">æ­£åœ¨åŠ è½½...</option>
                        </select>
                        <div class="model-chip" id="targetModelStatus">æœªé€‰æ‹©</div>
                    </div>
                    <div class="model-select-item">
                        <label>ç«åŠ›åˆ†é…æ¨¡å‹ï¼š</label>
                        <select id="fireModelSelect" class="model-select">
                            <option value="">æ­£åœ¨åŠ è½½...</option>
                        </select>
                        <div class="model-chip" id="fireModelStatus">æœªé€‰æ‹©</div>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label>å½“å‰åœºæ™¯ï¼š</label>
                <span id="currentScenario">æœªé€‰æ‹©</span>
            </div>
            
            <div class="control-group">
                <label>ä»¿çœŸçŠ¶æ€ï¼š</label>
                <span class="status-badge" id="simStatus">å°±ç»ª</span>
            </div>
            <div class="control-group">
                <label>æˆ‘æ–¹æ— äººæœºï¼š</label>
                <span id="droneCount">0</span>
            </div>
            <div class="control-group">
                <label>æ•Œæ–¹å•ä½ï¼š</label>
                <span id="enemyCount">0</span>
            </div>
            <div class="control-group">
                <label>ä½œæˆ˜åŒºåŸŸï¼š</label>
                <span>å°æ¹¾æµ·å³¡</span>
            </div>
            <div class="control-group">
                <label>å¤©æ°”çŠ¶å†µï¼š</label>
                <span style="color: #28a745;">è‰¯å¥½</span>
            </div>
            <div class="control-group">
                <label>æµ·å†µç­‰çº§ï¼š</label>
                <span style="color: #007bff;">3çº§</span>
            </div>
            <div class="control-buttons">
                <button class="btn btn-primary" id="startSim">
                    <i class="fas fa-play"></i> å¼€å§‹ä»¿çœŸ
                </button>
                <button class="btn btn-danger" id="stopSim">
                    <i class="fas fa-stop"></i> åœæ­¢
                </button>
            </div>
            <div class="info-section">
                <h4>åœ°å›¾æ“ä½œè¯´æ˜ï¼š</h4>
                <ul>
                    <li>é¼ æ ‡æ‹–æ‹½ï¼šç§»åŠ¨åœ°å›¾</li>
                    <li>æ»šè½®ç¼©æ”¾ï¼šæ”¾å¤§/ç¼©å°åœ°å›¾</li>
                    <li>ç‚¹å‡»æ ‡è®°ï¼šæŸ¥çœ‹è¯¦ç»†ä¿¡æ¯</li>
                    <li>å›¾å±‚åˆ‡æ¢ï¼šä½¿ç”¨å³ä¸Šè§’æ§åˆ¶å™¨</li>
                </ul>
            </div>
            <div class="info-section">
                <h4>å›¾ä¾‹è¯´æ˜ï¼š</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 0.8rem;">
                    <div>âœˆï¸ æˆ‘æ–¹æ— äººæœº</div>
                    <div>ğŸ”´ æ•Œæ–¹å•ä½</div>
                    <div>ğŸš ä¾¦å¯Ÿæ— äººæœº</div>
                    <div>ğŸš æ­¦è£…ç›´å‡æœº</div>
                    <div>ğŸ’ª å¦å…‹</div>
                    <div>ğŸš— è£…ç”²è½¦</div>
                    <div>ğŸ¢ å†›äº‹åŸºåœ°</div>
                    <div>ğŸŒŠ æµ·åŸŸ</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- åœ°å›¾åŒºåŸŸ -->
    <div class="map-container">
        <div id="simulationMap" class="simulation-map"></div>
        <div class="sim-message-container" id="simMessageContainer"></div>
        
        <!-- åœ°å›¾ä¿¡æ¯æ˜¾ç¤º -->
        <div class="map-info" id="mapInfo">
            <div class="coords-info">
                <span>ç»åº¦ï¼š</span><span id="longitude">--</span>
                <span>çº¬åº¦ï¼š</span><span id="latitude">--</span>
                <span>ç¼©æ”¾çº§åˆ«ï¼š</span><span id="zoomLevel">--</span>
            </div>
        </div>
        
        <div class="battle-summary-panel" id="battleSummaryPanel" style="display: none;">
            <div class="summary-header">
                <div>
                    <div class="summary-title">ä»¿çœŸç»“æŸ</div>
                    <div class="summary-subtitle" id="summaryReason">æ•Œæ–¹å…¨éƒ¨è¢«å‡»æ¯</div>
                </div>
                <button class="btn btn-info btn-sm" id="closeSummary">éšè—</button>
            </div>
            <div class="summary-body">
                <div class="summary-metrics">
                    <div class="metric">
                        <span>ä½œæˆ˜æ—¶é•¿</span>
                        <strong id="summaryDuration">--</strong>
                    </div>
                    <div class="metric">
                        <span>å¼¹è¯å‘å°„</span>
                        <strong id="summaryShots">0</strong>
                    </div>
                    <div class="metric">
                        <span>å‘½ä¸­ / å‡»æ¯</span>
                        <strong><span id="summaryHits">0</span> / <span id="summaryKills">0</span></strong>
                    </div>
                    <div class="metric">
                        <span>æ•Œæ–¹å‰©ä½™</span>
                        <strong id="summaryEnemyRemaining">0</strong>
                    </div>
                    <div class="metric">
                        <span>æˆ‘æ–¹å‰©ä½™</span>
                        <strong id="summaryOurRemaining">0</strong>
                    </div>
                </div>
                <div class="summary-charts">
                    <div class="chart-card">
                        <div class="chart-title">å¼¹è¯å‘å°„åˆ†å¸ƒ</div>
                        <canvas id="ammoUsageChart"></canvas>
                        <div class="chart-empty" id="ammoChartEmpty" style="display: none;">æš‚æ— æ•°æ®</div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-title">ç›®æ ‡å‡»æ¯åˆ†å¸ƒ</div>
                        <canvas id="killDistributionChart"></canvas>
                        <div class="chart-empty" id="killChartEmpty" style="display: none;">æš‚æ— æ•°æ®</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- æ·»åŠ æ ·å¼ -->
<style>
.scenario-selection {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 15px;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 5px;
}

.scenario-select {
    flex: 1 1 180px;
    min-width: 0;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

.scenario-selection #loadScenario {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    flex: 0 0 auto;
}

@media (max-width: 1200px) {
    .scenario-selection {
        flex-direction: column;
        align-items: stretch;
    }
    .scenario-selection #loadScenario {
        width: 100%;
        justify-content: center;
    }
}

.btn-info {
    background-color: #17a2b8;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

.btn-info:hover {
    background-color: #138496;
}

.btn-sm {
    padding: 6px 12px;
    font-size: 12px;
}

/* ä»¿çœŸçŠ¶æ€æ ·å¼ */
.status-badge {
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
    background-color: #6c757d;
    color: white;
}

.status-badge.running {
    background-color: #28a745;
    animation: pulse 2s infinite;
}

.status-badge.paused {
    background-color: #ffc107;
    color: #212529;
}

.control-panel .btn:disabled,
.control-panel .btn.disabled {
    cursor: not-allowed;
    opacity: 0.6;
    box-shadow: none;
}

.model-select-block {
    background: #f9fafb;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
}

.model-select-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    font-weight: 600;
    color: #1f2937;
}

.required-flag {
    font-size: 12px;
    color: #d97706;
    background: #fef3c7;
    border: 1px solid #fcd34d;
    padding: 3px 8px;
    border-radius: 999px;
}

.model-select-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
}

.model-select-item {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.model-select {
    padding: 8px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-size: 14px;
}

.model-select:disabled {
    background: #f3f4f6;
    cursor: not-allowed;
}

.model-chip {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 999px;
    background: #f3f4f6;
    color: #6b7280;
    font-size: 12px;
    border: 1px dashed #e5e7eb;
    max-width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.model-chip.active {
    background: #eef2ff;
    color: #4338ca;
    border-color: #c7d2fe;
}

.target-highlight {
    box-shadow: 0 0 0 4px rgba(255, 82, 82, 0.35), 0 0 12px rgba(255, 82, 82, 0.6);
    transform: scale(1.08);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.unit-destroying {
    animation: explodeFade 0.8s forwards;
    transform-origin: center;
    filter: drop-shadow(0 0 12px rgba(239, 68, 68, 0.8));
}

@keyframes explodeFade {
    0% { transform: scale(1); opacity: 1; }
    30% { transform: scale(1.4); opacity: 0.9; }
    60% { transform: scale(1.1); opacity: 0.5; }
    100% { transform: scale(0.6); opacity: 0; }
}

.distance-tooltip {
    background: #111827;
    color: #fff;
    border: 1px solid #60a5fa;
    border-radius: 4px;
    padding: 2px 6px;
    font-size: 12px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
}

.sim-message-container {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 1200;
    pointer-events: none;
}

.sim-message {
    min-width: 260px;
    padding: 10px 14px;
    border-radius: 6px;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18);
    background: rgba(17, 24, 39, 0.9);
    color: #fff;
    font-size: 0.9rem;
    border-left: 4px solid #60a5fa;
    animation: fadeSlide 2s forwards;
}

.sim-message.success { border-color: #34d399; }
.sim-message.warning { border-color: #fbbf24; }
.sim-message.danger { border-color: #ef4444; }

@keyframes fadeSlide {
    0% { opacity: 0; transform: translateY(-8px); }
    10% { opacity: 1; transform: translateY(0); }
    80% { opacity: 1; transform: translateY(0); }
    100% { opacity: 0; transform: translateY(-8px); }
}

.battle-summary-panel {
    position: absolute;
    bottom: 14px;
    left: 14px;
    right: 14px;
    background: rgba(255, 255, 255, 0.97);
    border-radius: 12px;
    box-shadow: 0 12px 28px rgba(0, 0, 0, 0.18);
    padding: 16px;
    z-index: 1100;
    backdrop-filter: blur(8px);
}

.summary-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    margin-bottom: 10px;
}

.summary-title {
    font-weight: 700;
    font-size: 1.05rem;
    color: #1f2937;
}

.summary-subtitle {
    color: #6b7280;
    font-size: 0.9rem;
}

.summary-body {
    display: flex;
    flex-direction: column;
    gap: 14px;
}

.summary-metrics {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 10px;
}

.metric {
    background: #f9fafb;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 10px;
}

.metric span {
    display: block;
    color: #6b7280;
    font-size: 0.85rem;
    margin-bottom: 4px;
}

.metric strong {
    color: #111827;
    font-size: 1rem;
}

.summary-charts {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    gap: 12px;
}

.chart-card {
    background: #f9fafb;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 10px;
    min-height: 220px;
    position: relative;
}

.chart-title {
    font-weight: 600;
    color: #374151;
    margin-bottom: 8px;
}

.chart-empty {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #9ca3af;
    font-size: 0.9rem;
    background: rgba(255, 255, 255, 0.85);
    border-radius: 8px;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}
</style>

<!-- Leaflet.js JavaScript -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
// å…¨å±€å˜é‡
let map;
let droneMarkers = [];
let enemyMarkers = [];
let isSimulationRunning = false;
let isPaused = false;
let currentScenarioData = null;
let targetModels = [];
let fireModels = [];
let selectedTargetModel = null;
let selectedFireModel = null;
let simulationInterval = null;
let simulationSpeed = 1000; // ä»¿çœŸæ›´æ–°é—´éš”(æ¯«ç§’)
let activeHighlightLine = null;
let activeHighlightedTarget = null;
let activeHighlightedDrone = null;
let activeHighlightTooltip = null;
let enemyUnitValueMap = {};
let maxEnemyUnitValue = 120;
let targetAssignmentCounts = {};
let weaponConfigMap = {};
const FIRE_COOLDOWN_MS = 3000;
const MESSAGE_DURATION_MS = 2000;
const DESTRUCTION_ANIMATION_MS = 800;
const AIR_TARGET_TYPES = ['reconnaissance_drone', 'attack_helicopter'];
const GROUND_TARGET_TYPES = ['tank', 'armored_vehicle', 'military_base'];
const UNIT_TYPE_LABELS = {
    reconnaissance_drone: 'ä¾¦å¯Ÿæ— äººæœº',
    attack_helicopter: 'æ­¦è£…ç›´å‡æœº',
    tank: 'å¦å…‹',
    armored_vehicle: 'è£…ç”²è½¦',
    military_base: 'å†›äº‹åŸºåœ°'
};

let battleStats = {
    shotsFired: 0,
    hits: 0,
    destroyed: 0,
    ammoUsage: {},
    killsByType: {},
    startTime: null,
    endTime: null,
    initialEnemyCount: 0,
    initialDroneCount: 0,
    resultReason: ''
};
let ammoUsageChart = null;
let killDistributionChart = null;

// å•ä½è¿åŠ¨æ•°æ®
let unitMovementData = {
    ourDrones: [],
    enemyUnits: []
};

// å•ä½é€Ÿåº¦é…ç½® (km/h)
const UNIT_SPEEDS = {
    our_drone: 150, // æˆ‘æ–¹æ— äººæœºé€Ÿåº¦
    reconnaissance_drone: 120,
    attack_helicopter: 200,
    tank: 50,
    armored_vehicle: 80,
    military_base: 0 // åŸºåœ°ä¸ç§»åŠ¨
};

// æ—¥å¿—ä¿å­˜å‡½æ•°
function saveLog(message, level = 'INFO') {
    // åœ¨æ§åˆ¶å°æ˜¾ç¤ºæ—¥å¿—
    console.log(message);
    
    // æ£€æŸ¥æ¶ˆæ¯é•¿åº¦ï¼Œå¦‚æœå¤ªé•¿åˆ™æˆªæ–­
    let logMessage = message;
    if (logMessage.length > 2000) {
        logMessage = logMessage.substring(0, 1997) + '...';
        console.warn('æ—¥å¿—æ¶ˆæ¯è¿‡é•¿ï¼Œå·²æˆªæ–­è‡³ 2000 ä¸ªå­—ç¬¦');
    }
    
    // å‘é€æ—¥å¿—åˆ°åç«¯ä¿å­˜
    fetch('/api/save_log', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            message: logMessage,
            level: level
        })
    })
    .then(response => response.json())
    .then(data => {
        if (!data.success) {
            console.error('ä¿å­˜æ—¥å¿—å¤±è´¥:', data.message);
        }
    })
    .catch(error => {
        console.error('å‘é€æ—¥å¿—è¯·æ±‚å¤±è´¥:', error);
    });
}

// åŠ è½½æ•Œæ–¹å•ä½ä»·å€¼é…ç½®
function loadEnemyConfig() {
    fetch('/static/config/enemy_unit_config.json')
        .then(response => response.json())
        .then(data => {
            enemyUnitValueMap = {};
            maxEnemyUnitValue = 1;
            if (data && Array.isArray(data.units)) {
                data.units.forEach(unit => {
                    if (unit.type) {
                        enemyUnitValueMap[unit.type] = unit.value || 50;
                        maxEnemyUnitValue = Math.max(maxEnemyUnitValue, unit.value || 50);
                    }
                });
            }
            saveLog('æ•Œæ–¹å•ä½é…ç½®åŠ è½½å®Œæˆ');
        })
        .catch(error => {
            saveLog('æ•Œæ–¹å•ä½é…ç½®åŠ è½½å¤±è´¥ï¼š' + error.message, 'ERROR');
            enemyUnitValueMap = {};
            maxEnemyUnitValue = 120;
        });
}

// åŠ è½½æ­¦å™¨é…ç½®
function loadWeaponConfig() {
    fetch('/static/config/weapon_config.json')
        .then(response => response.json())
        .then(data => {
            weaponConfigMap = {};
            if (data && Array.isArray(data.weapons)) {
                data.weapons.forEach(weapon => {
                    if (weapon.code) {
                        weaponConfigMap[weapon.code] = weapon;
                    }
                });
            }
            saveLog('æ­¦å™¨é…ç½®åŠ è½½å®Œæˆ');
        })
        .catch(error => {
            saveLog('æ­¦å™¨é…ç½®åŠ è½½å¤±è´¥ï¼š' + error.message, 'ERROR');
            weaponConfigMap = {};
        });
}

function clearTransientMessages() {
    const container = document.getElementById('simMessageContainer');
    if (container) {
        container.innerHTML = '';
    }
}

function showAttackMessage(message, level = 'info') {
    const container = document.getElementById('simMessageContainer');
    if (!container) return;
    const item = document.createElement('div');
    const levelClass = level === 'success' ? 'success' : level === 'danger' ? 'danger' : level === 'warning' ? 'warning' : '';
    item.className = `sim-message ${levelClass}`.trim();
    item.textContent = message;
    container.appendChild(item);
    setTimeout(() => {
        if (item && item.parentNode) {
            item.parentNode.removeChild(item);
        }
    }, MESSAGE_DURATION_MS);
}

function destroyCharts() {
    if (ammoUsageChart) {
        ammoUsageChart.destroy();
        ammoUsageChart = null;
    }
    if (killDistributionChart) {
        killDistributionChart.destroy();
        killDistributionChart = null;
    }
}

function resetBattleStats() {
    battleStats = {
        shotsFired: 0,
        hits: 0,
        destroyed: 0,
        ammoUsage: {},
        killsByType: {},
        startTime: null,
        endTime: null,
        initialEnemyCount: 0,
        initialDroneCount: 0,
        resultReason: ''
    };
    destroyCharts();
    const panel = document.getElementById('battleSummaryPanel');
    if (panel) {
        panel.style.display = 'none';
    }
}

function recordShot(weaponCode) {
    battleStats.shotsFired += 1;
    if (weaponCode) {
        battleStats.ammoUsage[weaponCode] = (battleStats.ammoUsage[weaponCode] || 0) + 1;
    }
}

function recordHit(hit, destroyed, targetMarker) {
    if (hit) {
        battleStats.hits += 1;
    }
    if (destroyed) {
        battleStats.destroyed += 1;
        const type = targetMarker && targetMarker.unitData ? targetMarker.unitData.type || 'æœªçŸ¥' : 'æœªçŸ¥';
        battleStats.killsByType[type] = (battleStats.killsByType[type] || 0) + 1;
    }
}

function formatDuration(seconds) {
    if (!isFinite(seconds) || seconds < 0) return '--';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}åˆ†${secs}ç§’`;
}

function renderCharts() {
    destroyCharts();
    if (typeof Chart === 'undefined') {
        console.warn('Chart.js æœªåŠ è½½ï¼Œè·³è¿‡å›¾è¡¨æ¸²æŸ“');
        return;
    }
    const ammoCanvas = document.getElementById('ammoUsageChart');
    const ammoEmpty = document.getElementById('ammoChartEmpty');
    const ammoEntries = Object.entries(battleStats.ammoUsage || {});
    if (ammoCanvas) {
        const ctx = ammoCanvas.getContext('2d');
        if (ammoEntries.length) {
            if (ammoEmpty) ammoEmpty.style.display = 'none';
            ammoUsageChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ammoEntries.map(([code]) => (weaponConfigMap[code] ? weaponConfigMap[code].name : code.toUpperCase())),
                    datasets: [{
                        label: 'å‘å°„æ¬¡æ•°',
                        data: ammoEntries.map(([, count]) => count),
                        backgroundColor: '#60a5fa'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: { legend: { display: false } },
                    scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
                }
            });
        } else if (ammoEmpty) {
            ammoEmpty.style.display = 'flex';
        }
    }

    const killCanvas = document.getElementById('killDistributionChart');
    const killEmpty = document.getElementById('killChartEmpty');
    const killEntries = Object.entries(battleStats.killsByType || {});
    if (killCanvas) {
        const ctx = killCanvas.getContext('2d');
        if (killEntries.length) {
            if (killEmpty) killEmpty.style.display = 'none';
            killDistributionChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: killEntries.map(([type]) => UNIT_TYPE_LABELS[type] || type),
                    datasets: [{
                        data: killEntries.map(([, count]) => count),
                        backgroundColor: ['#34d399', '#fbbf24', '#60a5fa', '#f472b6', '#a78bfa']
                    }]
                },
                options: {
                    responsive: true,
                    plugins: { legend: { position: 'bottom' } }
                }
            });
        } else if (killEmpty) {
            killEmpty.style.display = 'flex';
        }
    }
}

function renderBattleSummary(reason = 'ä»¿çœŸç»“æŸ') {
    const panel = document.getElementById('battleSummaryPanel');
    if (!panel) return;
    battleStats.resultReason = reason;
    battleStats.endTime = battleStats.endTime || Date.now();
    const durationSec = battleStats.startTime ? (battleStats.endTime - battleStats.startTime) / 1000 : 0;
    const enemyRemaining = enemyMarkers.length;
    const ourRemaining = unitMovementData.ourDrones.length;

    document.getElementById('summaryReason').textContent = reason;
    const durationEl = document.getElementById('summaryDuration');
    if (durationEl) durationEl.textContent = formatDuration(durationSec);
    document.getElementById('summaryShots').textContent = battleStats.shotsFired;
    document.getElementById('summaryHits').textContent = battleStats.hits;
    document.getElementById('summaryKills').textContent = battleStats.destroyed;
    document.getElementById('summaryEnemyRemaining').textContent = enemyRemaining;
    document.getElementById('summaryOurRemaining').textContent = ourRemaining;

    panel.style.display = 'block';
    renderCharts();
}

function hideBattleSummary() {
    const panel = document.getElementById('battleSummaryPanel');
    if (panel) panel.style.display = 'none';
}

function finishSimulation(reason) {
    if (!isSimulationRunning) return;
    isSimulationRunning = false;
    isPaused = false;
    stopSimulationLoop();
    battleStats.endTime = Date.now();
    renderBattleSummary(reason);
    document.getElementById('simStatus').textContent = 'å·²ç»“æŸ';
    document.getElementById('simStatus').className = 'status-badge';
    document.getElementById('startSim').innerHTML = '<i class="fas fa-play"></i> å¼€å§‹ä»¿çœŸ';
    updateStartButtonState();
    showAttackMessage(`ä»¿çœŸç»“æŸï¼š${reason}`, 'success');
    saveLog(`ä»¿çœŸç»“æŸï¼š${reason}`);
}

function checkSimulationEnd() {
    if (!isSimulationRunning) return;
    if (enemyMarkers.length === 0) {
        finishSimulation('æ•Œæ–¹å…¨éƒ¨è¢«å‡»æ¯');
    } else if (unitMovementData.ourDrones.length === 0) {
        finishSimulation('æˆ‘æ–¹å…¨éƒ¨è¢«å‡»æ¯');
    }
}

// åˆå§‹åŒ–åœ°å›¾
function initMap() {
    // åˆ›å»ºåœ°å›¾å®ä¾‹ï¼ˆä»¥å°æ¹¾æµ·å³¡ä¸ºä¸­å¿ƒï¼‰
    // å°æ¹¾æµ·å³¡ä¸­å¿ƒä½ç½®ï¼šåŒ—çº¬24.5Â°ï¼Œä¸œç»120.0Â°
    map = L.map('simulationMap').setView([24.5, 120.0], 8);
    
    // å®šä¹‰å¤šç§åœ°å›¾å›¾å±‚
    const baseMaps = {
        'æ ‡å‡†åœ°å›¾': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 19
        }),
        
        'å«æ˜Ÿå›¾': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
            maxZoom: 19
        }),
        
        'åœ°å½¢å›¾': L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
            maxZoom: 17
        })
    };
    
    // é»˜è®¤ä½¿ç”¨å«æ˜Ÿå›¾ï¼ˆæ›´é€‚åˆæµ·ä¸Šä½œæˆ˜ï¼‰
    baseMaps['å«æ˜Ÿå›¾'].addTo(map);
    
    // æ·»åŠ å›¾å±‚æ§åˆ¶å™¨
    L.control.layers(baseMaps).addTo(map);
    
    // æ·»åŠ æ¯”ä¾‹å°ºæ§ä»¶
    L.control.scale().addTo(map);
    
    // ç›‘å¬åœ°å›¾äº‹ä»¶
    map.on('mousemove', function(e) {
        updateMapInfo(e.latlng.lat, e.latlng.lng, map.getZoom());
    });
    
    map.on('zoomend', function() {
        const center = map.getCenter();
        updateMapInfo(center.lat, center.lng, map.getZoom());
    });
    
    saveLog('å°æ¹¾æµ·å³¡åœ°å›¾åˆå§‹åŒ–å®Œæˆ');
}

// æ›´æ–°åœ°å›¾ä¿¡æ¯æ˜¾ç¤º
function updateMapInfo(lat, lng, zoom) {
    document.getElementById('latitude').textContent = lat.toFixed(6);
    document.getElementById('longitude').textContent = lng.toFixed(6);
    document.getElementById('zoomLevel').textContent = zoom;
}

function showLoadScenarioButton() {
    const btn = document.getElementById('loadScenario');
    if (btn) {
        btn.style.display = 'inline-flex';
    }
}

// åŠ è½½åœºæ™¯åˆ—è¡¨
function loadScenarios() {
    fetch('/api/scenarios')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showLoadScenarioButton();
                const select = document.getElementById('scenarioSelect');
                select.innerHTML = '<option value="">è¯·é€‰æ‹©åœºæ™¯...</option>';
                
                data.scenarios.forEach(scenario => {
                    const option = document.createElement('option');
                    option.value = scenario.id;
                    option.textContent = `${scenario.name} (æˆ‘æ–¹:${scenario.our_drone_count} æ•Œæ–¹:${scenario.enemy_total})`;
                    select.appendChild(option);
                });
                
                saveLog(`åŠ è½½äº† ${data.scenarios.length} ä¸ªåœºæ™¯åˆ°é€‰æ‹©åˆ—è¡¨`);
            } else {
                saveLog('åŠ è½½åœºæ™¯åˆ—è¡¨å¤±è´¥: ' + data.message, 'ERROR');
            }
        })
        .catch(error => {
            showLoadScenarioButton();
            saveLog('è·å–åœºæ™¯åˆ—è¡¨æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'ERROR');
        });
}

// åŠ è½½æ¨¡å‹åˆ—è¡¨
function loadModels() {
    fetch('/api/models')
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                saveLog('åŠ è½½æ¨¡å‹åˆ—è¡¨å¤±è´¥: ' + data.message, 'ERROR');
                return;
            }
            targetModels = data.models.filter(model => model.category === 'target_allocation');
            fireModels = data.models.filter(model => model.category === 'fire_allocaltion');
            populateModelSelect('targetModelSelect', targetModels, 'è¯·é€‰æ‹©ç›®æ ‡åˆ†é…æ¨¡å‹...');
            populateModelSelect('fireModelSelect', fireModels, 'è¯·é€‰æ‹©ç«åŠ›åˆ†é…æ¨¡å‹...');
            updateModelSelectionDisplay();
            updateStartButtonState();
            saveLog(`åŠ è½½æ¨¡å‹åˆ—è¡¨æˆåŠŸï¼šç›®æ ‡åˆ†é… ${targetModels.length} ä¸ªï¼Œç«åŠ›åˆ†é… ${fireModels.length} ä¸ª`);
        })
        .catch(error => {
            saveLog('è·å–æ¨¡å‹åˆ—è¡¨æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'ERROR');
        });
}

// å¡«å……æ¨¡å‹ä¸‹æ‹‰æ¡†
function populateModelSelect(selectId, models, placeholder) {
    const select = document.getElementById(selectId);
    if (!select) return;

    select.innerHTML = '';
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = models.length ? placeholder : 'æš‚æ— å¯ç”¨æ¨¡å‹';
    select.appendChild(defaultOption);

    models.forEach(model => {
        const option = document.createElement('option');
        option.value = model.id;
        option.textContent = `${model.name}${model.version ? ' Â· ' + model.version : ''}`;
        select.appendChild(option);
    });

    select.disabled = models.length === 0;
}

// æ›´æ–°æ¨¡å‹é€‰æ‹©çŠ¶æ€å±•ç¤º
function updateModelSelectionDisplay() {
    const targetStatus = document.getElementById('targetModelStatus');
    const fireStatus = document.getElementById('fireModelStatus');

    if (targetStatus) {
        if (selectedTargetModel) {
            targetStatus.textContent = `${selectedTargetModel.name}${selectedTargetModel.version ? ' Â· ' + selectedTargetModel.version : ''}`;
            targetStatus.classList.add('active');
        } else {
            targetStatus.textContent = 'æœªé€‰æ‹©';
            targetStatus.classList.remove('active');
        }
    }

    if (fireStatus) {
        if (selectedFireModel) {
            fireStatus.textContent = `${selectedFireModel.name}${selectedFireModel.version ? ' Â· ' + selectedFireModel.version : ''}`;
            fireStatus.classList.add('active');
        } else {
            fireStatus.textContent = 'æœªé€‰æ‹©';
            fireStatus.classList.remove('active');
        }
    }
}

// æ£€æŸ¥ä»¿çœŸæ˜¯å¦å¯ä»¥å¯åŠ¨
function isSimulationReady() {
    return Boolean(currentScenarioData && selectedTargetModel && selectedFireModel);
}

function updateStartButtonState() {
    const startBtn = document.getElementById('startSim');
    if (!startBtn) return;
    const canStart = isSimulationReady() || isSimulationRunning;
    startBtn.disabled = !canStart;
    if (startBtn.disabled) {
        startBtn.classList.add('disabled');
        startBtn.title = 'è¯·é€‰æ‹©åœºæ™¯ï¼Œå¹¶é€‰æ‹©ç›®æ ‡åˆ†é…/ç«åŠ›åˆ†é…æ¨¡å‹åå†å¼€å§‹';
    } else {
        startBtn.classList.remove('disabled');
        startBtn.title = '';
    }
}

// æ¸…é™¤åœ°å›¾ä¸Šçš„æ‰€æœ‰æ ‡è®°
function clearMapMarkers() {
    // æ¸…é™¤æˆ‘æ–¹æ— äººæœºæ ‡è®°
    droneMarkers.forEach(marker => {
        map.removeLayer(marker);
    });
    droneMarkers = [];
    
    // æ¸…é™¤æ•Œæ–¹å•ä½æ ‡è®°
    enemyMarkers.forEach(marker => {
        map.removeLayer(marker);
    });
    enemyMarkers = [];
    
    clearTargetHighlight();
    saveLog('æ¸…é™¤åœ°å›¾ä¸Šçš„æ‰€æœ‰æ ‡è®°');
}

// è·å–æ ‡è®°å›¾æ ‡
function getMarkerIcon(type, side = 'enemy') {
    const icons = {
        // æˆ‘æ–¹æ— äººæœº
        our_drone: 'âœˆï¸',
        
        // æ•Œæ–¹å•ä½
        reconnaissance_drone: 'ğŸš',
        attack_helicopter: 'ğŸš', 
        tank: 'ğŸ†',
        armored_vehicle: 'ğŸš—',
        military_base: 'ğŸ¢'
    };
    
    const colors = {
        our_drone: '#007bff',
        reconnaissance_drone: '#dc3545',
        attack_helicopter: '#dc3545',
        tank: '#dc3545',
        armored_vehicle: '#dc3545',
        military_base: '#dc3545'
    };
    
    const iconKey = side === 'our' ? 'our_drone' : type;
    
    return L.divIcon({
        html: `<div style="
            font-size: 20px; 
            text-align: center; 
            line-height: 1;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));
            background: ${colors[iconKey] || '#6c757d'};
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
        ">${icons[iconKey] || 'âœˆï¸'}</div>`,
        className: 'custom-marker',
        iconSize: [32, 32],
        iconAnchor: [16, 16]
    });
}

// ç”Ÿæˆéšæœºç›®æ ‡ä½ç½®
function generateRandomTarget(currentLat, currentLng, maxDistance = 0.1) {
    // ç”Ÿæˆéšæœºæ–¹å‘å’Œè·ç¦»
    const angle = Math.random() * 2 * Math.PI;
    const distance = Math.random() * maxDistance;
    
    // è®¡ç®—æ–°çš„ç»çº¬åº¦
    const newLat = currentLat + (distance * Math.cos(angle));
    const newLng = currentLng + (distance * Math.sin(angle));
    
    return { lat: newLat, lng: newLng };
}

// è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦» (å…¬é‡Œ)
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371; // åœ°çƒåŠå¾„ï¼ˆå…¬é‡Œï¼‰
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

function setMarkerTooltip(marker, content) {
    const existingTooltip = marker.getTooltip ? marker.getTooltip() : null;
    if (existingTooltip) {
        if (marker.setTooltipContent) {
            marker.setTooltipContent(content);
        } else if (existingTooltip.setContent) {
            existingTooltip.setContent(content);
        }
    } else {
        marker.bindTooltip(content, {
            direction: 'top',
            opacity: 0.9,
            offset: [0, -4]
        });
    }
}

function formatTargetLabel(targetMarker) {
    if (!targetMarker) {
        return 'æœªåˆ†é…';
    }
    const unitData = targetMarker.unitData || {};
    return unitData.code || 'æœªè®¾ç½®';
}

function formatPayloadSummary(droneData = {}) {
    const ar1 = droneData.ar1 || 0;
    const pl10 = droneData.pl10 || 0;
    const cannon = droneData.cannon || 0;
    return `è½½è·ï¼šç©ºåœ°å¯¼å¼¹:${ar1} ç©ºç©ºå¯¼å¼¹:${pl10} æœºç‚®:${cannon}`;
}

function updateDroneTooltip(unit) {
    const label = formatTargetLabel(unit.targetMarker);
    const codeLabel = unit.data && unit.data.code ? unit.data.code : 'æœªè®¾ç½®';
    const payload = formatPayloadSummary(unit.data || {});
    const content = `ç¼–å·ï¼š${codeLabel}<br/>${payload}<br/>å½“å‰æ”»å‡»ç›®æ ‡ï¼š${label}`;
    setMarkerTooltip(unit.marker, content);
    unit.marker.currentTarget = unit.targetMarker;
}

function clearTargetHighlight() {
    if (activeHighlightLine) {
        map.removeLayer(activeHighlightLine);
        activeHighlightLine = null;
    }
    if (activeHighlightTooltip) {
        map.removeLayer(activeHighlightTooltip);
        activeHighlightTooltip = null;
    }
    if (activeHighlightedTarget && activeHighlightedTarget._icon) {
        activeHighlightedTarget._icon.classList.remove('target-highlight');
    }
    activeHighlightedTarget = null;
    activeHighlightedDrone = null;
}

function updateHighlightDistance() {
    if (!activeHighlightLine || !activeHighlightedDrone || !activeHighlightedTarget) return;
    const from = activeHighlightedDrone.getLatLng();
    const to = activeHighlightedTarget.getLatLng();
    const distanceKm = calculateDistance(from.lat, from.lng, to.lat, to.lng);
    const text = `${distanceKm.toFixed(2)} km`;
    if (!activeHighlightTooltip) {
        activeHighlightTooltip = L.tooltip({
            permanent: true,
            direction: 'center',
            className: 'distance-tooltip',
            offset: [0, -4]
        })
        .setLatLng(L.latLng(
            (from.lat + to.lat) / 2,
            (from.lng + to.lng) / 2
        ))
        .setContent(text)
        .addTo(map);
    } else {
        activeHighlightTooltip.setLatLng(L.latLng(
            (from.lat + to.lat) / 2,
            (from.lng + to.lng) / 2
        ));
        if (activeHighlightTooltip.setContent) {
            activeHighlightTooltip.setContent(text);
        }
    }
}

function highlightTargetForDrone(droneMarker) {
    const unit = unitMovementData.ourDrones.find(u => u.marker === droneMarker);
    const targetMarker = (unit && unit.targetMarker) || droneMarker.currentTarget;
    // å¦‚æœå½“å‰å°±æ˜¯é€‰ä¸­çš„æ— äººæœºï¼Œåˆ‡æ¢ä¸ºå–æ¶ˆé«˜äº®
    if (activeHighlightedDrone === droneMarker) {
        clearTargetHighlight();
        return;
    }

    clearTargetHighlight();
    if (!targetMarker) {
        return;
    }
    activeHighlightedTarget = targetMarker;
    activeHighlightedDrone = droneMarker;
    if (targetMarker._icon) {
        targetMarker._icon.classList.add('target-highlight');
    }
    activeHighlightLine = L.polyline(
        [droneMarker.getLatLng(), targetMarker.getLatLng()],
        { color: '#ff5252', weight: 3, dashArray: '8,4', opacity: 0.8 }
    ).addTo(map);
    if (targetMarker.bringToFront) targetMarker.bringToFront();
    if (droneMarker.bringToFront) droneMarker.bringToFront();
    updateHighlightDistance();
}

const TARGET_SELECTION_WEIGHTS = {
    value: 0.5,
    distance: 0.35,
    load: 0.15
};

function getTargetKey(marker) {
    if (!marker) return null;
    if (marker.unitIndex !== undefined) return marker.unitIndex;
    return marker._leaflet_id || null;
}

function incrementTargetAssignment(marker) {
    const key = getTargetKey(marker);
    if (key === null) return;
    targetAssignmentCounts[key] = (targetAssignmentCounts[key] || 0) + 1;
}

function decrementTargetAssignment(marker) {
    const key = getTargetKey(marker);
    if (key === null) return;
    if (targetAssignmentCounts[key]) {
        targetAssignmentCounts[key] = Math.max(0, targetAssignmentCounts[key] - 1);
    }
}

function getEnemyValue(marker) {
    const unitType = marker && marker.unitData ? marker.unitData.type : null;
    if (unitType && enemyUnitValueMap[unitType]) {
        return enemyUnitValueMap[unitType];
    }
    if (marker && marker.unitData && marker.unitData.value) {
        return marker.unitData.value;
    }
    return 50;
}

function getWeaponFromDrone(droneData, code) {
    if (!droneData) return null;
    const count = parseInt(droneData[code], 10);
    if (isNaN(count) || count <= 0) return null;
    const cfg = weaponConfigMap[code];
    if (!cfg) return null;
    return {
        code,
        count,
        config: cfg
    };
}

function getTargetCategory(targetMarker) {
    const type = targetMarker && targetMarker.unitData ? targetMarker.unitData.type || '' : '';
    const isAir = AIR_TARGET_TYPES.includes(type);
    const isGround = GROUND_TARGET_TYPES.includes(type);
    return { type, isAir, isGround };
}

function chooseWeaponForTarget(droneUnit, targetMarker, distanceKm) {
    if (!droneUnit || !targetMarker) return null;
    const droneData = droneUnit.data || {};
    const { isAir, isGround } = getTargetCategory(targetMarker);
    const candidates = ['ar1', 'pl10', 'cannon']
        .map(code => getWeaponFromDrone(droneData, code))
        .filter(Boolean);
    const filtered = candidates.filter(w => {
        if (w.code === 'ar1') return !isAir; // ç©ºåœ°å¯¼å¼¹ä»…æ”»å‡»åœ°é¢ç›®æ ‡
        if (w.code === 'pl10') return isAir;  // ç©ºç©ºå¯¼å¼¹ä»…æ”»å‡»ç©ºä¸­ç›®æ ‡
        return true; // æœºç‚®éƒ½å¯ä»¥æ”»å‡»
    });
    let best = null;
    filtered.forEach(w => {
        const cfg = w.config;
        const minRange = cfg.min_range_km || 0;
        const maxRange = cfg.max_range_km || 0;
        if (maxRange <= 0) return;
        if (distanceKm < minRange || distanceKm > maxRange) return;
        const score = cfg.hit_probability || 0;
        if (!best || score > best.score) {
            best = {
                code: w.code,
                config: cfg,
                score,
                maxRange
            };
        }
    });
    return best;
}

function applyWeaponConsumption(droneUnit, weaponCode) {
    if (!droneUnit || !droneUnit.data) return;
    const current = parseInt(droneUnit.data[weaponCode], 10);
    if (!isNaN(current) && current > 0) {
        droneUnit.data[weaponCode] = current - 1;
    }
}

function handleTargetDestroyed(targetMarker) {
    if (!targetMarker || targetMarker.isDestroyed) return;
    targetMarker.isDestroyed = true;
    decrementTargetAssignment(targetMarker);
    if (activeHighlightedTarget === targetMarker) {
        clearTargetHighlight();
    }
    const cleanupRemoval = () => {
        map.removeLayer(targetMarker);
        enemyMarkers = enemyMarkers.filter(m => m !== targetMarker);
        unitMovementData.enemyUnits = unitMovementData.enemyUnits.filter(u => u.marker !== targetMarker);
        saveLog(`ç›®æ ‡è¢«å‡»æ¯ï¼š${formatTargetLabel(targetMarker)}`);
        // è®©æ‰€æœ‰é’ˆå¯¹è¯¥ç›®æ ‡çš„æ— äººæœºé‡æ–°åˆ†é…
        unitMovementData.ourDrones.forEach(unit => {
            if (unit.targetMarker === targetMarker) {
                unit.targetMarker = pickRandomEnemyTarget(unit);
                if (unit.targetMarker) {
                    incrementTargetAssignment(unit.targetMarker);
                    unit.targetPos = unit.targetMarker.getLatLng();
                } else {
                    unit.targetPos = generateRandomTarget(unit.currentPos.lat, unit.currentPos.lng, 0.2);
                }
                updateDroneTooltip(unit);
            }
        });
        // æ›´æ–°è®¡æ•°æ˜¾ç¤º
        document.getElementById('enemyCount').textContent = enemyMarkers.length;
        checkSimulationEnd();
    };
    const icon = targetMarker._icon;
    if (icon) {
        icon.classList.add('unit-destroying');
        setTimeout(cleanupRemoval, DESTRUCTION_ANIMATION_MS);
    } else {
        cleanupRemoval();
    }
}

function attemptEngagement(unit) {
    if (!unit || !unit.isOur) return;
    if (!unit.targetMarker || unit.targetMarker.isDestroyed) return;
    const now = Date.now();
    if (unit.lastFireTime && now - unit.lastFireTime < FIRE_COOLDOWN_MS) {
        return;
    }
    const targetPos = unit.targetMarker.getLatLng();
    const dist = calculateDistance(unit.currentPos.lat, unit.currentPos.lng, targetPos.lat, targetPos.lng);
    const weapon = chooseWeaponForTarget(unit, unit.targetMarker, dist);
    if (!weapon) return;
    recordShot(weapon.code);
    unit.lastFireTime = now;
    applyWeaponConsumption(unit, weapon.code);
    const hitProbability = weapon.config.hit_probability || 0.5;
    const lethality = weapon.config.single_shot_lethality || 0.8;
    const roll = Math.random();
    const killRoll = Math.random();
    const hit = roll <= hitProbability;
    const destroyed = hit && killRoll <= lethality;
    recordHit(hit, destroyed, unit.targetMarker);
    const droneLabel = unit.data.code || 'æœªç¼–å·';
    const targetLabel = formatTargetLabel(unit.targetMarker);
    const weaponName = weapon.config.name || weapon.code.toUpperCase();
    const resultLabel = destroyed ? 'å‡»æ¯ç›®æ ‡' : (hit ? 'å‘½ä¸­æœªæ¯' : 'æœªå‘½ä¸­');
    const messageLevel = destroyed ? 'success' : (hit ? 'warning' : 'danger');
    showAttackMessage(`æ— äººæœº${droneLabel}ä½¿ç”¨${weaponName}æ”»å‡»${targetLabel}ï¼š${resultLabel}`, messageLevel);
    saveLog(`æ— äººæœº(${unit.data.code || 'æœªç¼–å·'}) ä½¿ç”¨ ${weapon.config.name} æ”»å‡» ${formatTargetLabel(unit.targetMarker)}ï¼Œè·ç¦» ${dist.toFixed(2)}kmï¼Œå‘½ä¸­æ·éª°=${roll.toFixed(2)}ï¼Œæ¯ä¼¤æ·éª°=${killRoll.toFixed(2)}ï¼Œç»“æœï¼š${destroyed ? 'å‡»æ¯' : (hit ? 'å‘½ä¸­æœªæ¯' : 'æœªå‘½ä¸­')}`);
    if (destroyed) {
        handleTargetDestroyed(unit.targetMarker);
    } else if (!enemyMarkers.length) {
        unit.targetMarker = null;
    }
}

// æ ¹æ®è·ç¦»ã€ä»·å€¼ä¸å½“å‰åˆ†é…è´Ÿè½½ç»¼åˆæŒ‘é€‰æœ€ä¼˜æ•Œæ–¹ç›®æ ‡
function pickRandomEnemyTarget(droneUnit = null) {
    if (!enemyMarkers.length) {
        return null;
    }
    const currentPos = droneUnit ? (droneUnit.currentPos || droneUnit.marker.getLatLng()) : null;
    let bestMarker = null;
    let bestScore = -Infinity;
    enemyMarkers.forEach(marker => {
        const targetPos = marker.getLatLng();
        const distanceKm = currentPos ? calculateDistance(
            currentPos.lat, currentPos.lng,
            targetPos.lat, targetPos.lng
        ) : 0;
        const valueScore = getEnemyValue(marker) / maxEnemyUnitValue;
        const distanceScore = 1 / (1 + distanceKm); // è¶Šè¿‘è¶Šé«˜
        const load = targetAssignmentCounts[getTargetKey(marker)] || 0;
        const loadScore = 1 / (1 + load);
        const score = TARGET_SELECTION_WEIGHTS.value * valueScore +
                      TARGET_SELECTION_WEIGHTS.distance * distanceScore +
                      TARGET_SELECTION_WEIGHTS.load * loadScore;
        if (score > bestScore) {
            bestScore = score;
            bestMarker = marker;
        }
    });
    return bestMarker;
}

// åˆå§‹åŒ–å•ä½è¿åŠ¨æ•°æ®
function initializeMovementData() {
    unitMovementData.ourDrones = [];
    unitMovementData.enemyUnits = [];
    targetAssignmentCounts = {};
    
    // åˆå§‹åŒ–æˆ‘æ–¹æ— äººæœºè¿åŠ¨æ•°æ®
    droneMarkers.forEach((marker, index) => {
        const currentPos = marker.getLatLng();
        const unitData = currentScenarioData.our_drones[index] || {};
        const unit = {
            marker: marker,
            currentPos: currentPos,
            targetPos: null,
            targetMarker: null,
            speed: UNIT_SPEEDS.our_drone,
            data: unitData,
            isOur: true,
            lastFireTime: 0
        };
        const targetMarker = pickRandomEnemyTarget(unit);
        unit.targetMarker = targetMarker;
        unit.targetPos = targetMarker ? targetMarker.getLatLng() : generateRandomTarget(currentPos.lat, currentPos.lng, 0.2);
        
        unitMovementData.ourDrones.push(unit);
        if (targetMarker) {
            incrementTargetAssignment(targetMarker);
        }
        marker.currentTarget = targetMarker;
        updateDroneTooltip(unit);
    });
    
    // åˆå§‹åŒ–æ•Œæ–¹å•ä½è¿åŠ¨æ•°æ®
    enemyMarkers.forEach((marker, index) => {
        const currentPos = marker.getLatLng();
        const unitData = currentScenarioData.enemy_units[index] || {};
        const unitType = unitData.type || 'reconnaissance_drone';
        
        // åŸºåœ°ä¸ç§»åŠ¨
        if (unitType === 'military_base') {
            return;
        }
        
        const target = generateRandomTarget(currentPos.lat, currentPos.lng, 0.15);
        
        unitMovementData.enemyUnits.push({
            marker: marker,
            currentPos: currentPos,
            targetPos: target,
            speed: UNIT_SPEEDS[unitType] || 100,
            type: unitType,
            data: unitData,
            isOur: false
        });
    });
    
    saveLog(`åˆå§‹åŒ–è¿åŠ¨æ•°æ®ï¼šæˆ‘æ–¹æ— äººæœº ${unitMovementData.ourDrones.length} æ¶ï¼Œæ•Œæ–¹ç§»åŠ¨å•ä½ ${unitMovementData.enemyUnits.length} ä¸ª`);
}

// æ›´æ–°å•ä½ä½ç½®
function updateUnitPositions() {
    if (!isSimulationRunning || isPaused) return;
    
    const updateInterval = simulationSpeed / 1000; // è½¬æ¢ä¸ºç§’
    
    // æ›´æ–°æˆ‘æ–¹æ— äººæœºä½ç½®
    unitMovementData.ourDrones.forEach(unit => {
        // æˆ‘æ–¹æ— äººæœºå§‹ç»ˆè¿½è¸ªç›®æ ‡æ ‡è®°çš„å®æ—¶ä½ç½®
        if (unit.targetMarker && !unit.targetMarker.isDestroyed) {
            unit.targetPos = unit.targetMarker.getLatLng();
        } else if (unit.targetMarker && unit.targetMarker.isDestroyed) {
            // å·²è¢«æ‘§æ¯åˆ™æ¢ç›®æ ‡
            unit.targetMarker = pickRandomEnemyTarget(unit);
            if (unit.targetMarker) {
                incrementTargetAssignment(unit.targetMarker);
                unit.targetPos = unit.targetMarker.getLatLng();
            } else {
                unit.targetPos = generateRandomTarget(unit.currentPos.lat, unit.currentPos.lng, 0.2);
            }
            updateDroneTooltip(unit);
        }
        moveUnitTowardsTarget(unit, updateInterval);
        attemptEngagement(unit);
    });
    
    // æ›´æ–°æ•Œæ–¹å•ä½ä½ç½®
    unitMovementData.enemyUnits.forEach(unit => {
        moveUnitTowardsTarget(unit, updateInterval);
    });

    // å¦‚æœæœ‰é«˜äº®è¿çº¿ï¼Œåˆ·æ–°ä½ç½®
    if (activeHighlightLine && activeHighlightedDrone && activeHighlightedTarget) {
        activeHighlightLine.setLatLngs([
            activeHighlightedDrone.getLatLng(),
            activeHighlightedTarget.getLatLng()
        ]);
        updateHighlightDistance();
    }
    checkSimulationEnd();
}

// ç§»åŠ¨å•ä½æœå‘ç›®æ ‡
function moveUnitTowardsTarget(unit, timeStep) {
    const { marker, currentPos, targetPos, speed } = unit;
    
    // è®¡ç®—è·ç¦»ç›®æ ‡çš„è·ç¦»
    const distanceToTarget = calculateDistance(
        currentPos.lat, currentPos.lng,
        targetPos.lat, targetPos.lng
    );
    
    // å¦‚æœå·²ç»æ¥è¿‘ç›®æ ‡ï¼Œç”Ÿæˆæ–°ç›®æ ‡
    if (distanceToTarget < 0.01) {
        if (unit.isOur) {
            // æˆ‘æ–¹æ— äººæœºåˆ°è¾¾åé‡æ–°éšæœºåˆ†é…æ–°çš„æ•Œæ–¹ç›®æ ‡
            decrementTargetAssignment(unit.targetMarker);
            const newTargetMarker = pickRandomEnemyTarget(unit);
            unit.targetMarker = newTargetMarker;
            if (newTargetMarker) {
                unit.targetPos = newTargetMarker.getLatLng();
                incrementTargetAssignment(newTargetMarker);
            } else {
                unit.targetPos = generateRandomTarget(currentPos.lat, currentPos.lng, 0.2);
            }
            updateDroneTooltip(unit);
        } else {
            unit.targetPos = generateRandomTarget(currentPos.lat, currentPos.lng, 0.2);
        }
        return;
    }
    
    // è®¡ç®—ç§»åŠ¨è·ç¦»ï¼ˆé€Ÿåº¦ * æ—¶é—´ï¼‰
    const moveDistance = (speed * timeStep) / 3600; // è½¬æ¢ä¸ºå…¬é‡Œ
    
    // è®¡ç®—ç§»åŠ¨æ–¹å‘
    const bearing = Math.atan2(
        targetPos.lng - currentPos.lng,
        targetPos.lat - currentPos.lat
    );
    
    // è®¡ç®—æ–°ä½ç½®
    const moveRatio = Math.min(moveDistance / distanceToTarget, 1);
    const newLat = currentPos.lat + (targetPos.lat - currentPos.lat) * moveRatio;
    const newLng = currentPos.lng + (targetPos.lng - currentPos.lng) * moveRatio;
    
    // æ›´æ–°æ ‡è®°ä½ç½®
    const newPos = L.latLng(newLat, newLng);
    marker.setLatLng(newPos);
    unit.currentPos = newPos;
}

// å¼€å§‹ä»¿çœŸå¾ªç¯
function startSimulationLoop() {
    if (simulationInterval) {
        clearInterval(simulationInterval);
    }
    
    simulationInterval = setInterval(updateUnitPositions, simulationSpeed);
    saveLog('ä»¿çœŸå¾ªç¯å·²å¯åŠ¨');
}

// åœæ­¢ä»¿çœŸå¾ªç¯
function stopSimulationLoop() {
    if (simulationInterval) {
        clearInterval(simulationInterval);
        simulationInterval = null;
        saveLog('ä»¿çœŸå¾ªç¯å·²åœæ­¢');
    }
}

// åŠ è½½åœºæ™¯æ•°æ®åˆ°åœ°å›¾
function loadScenarioToMap(scenarioId) {
    fetch(`/api/scenario/${scenarioId}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                currentScenarioData = data.scenario;
                
                // æ¸…é™¤ç°æœ‰æ ‡è®°
                clearMapMarkers();
                
                // æ›´æ–°åœºæ™¯ä¿¡æ¯æ˜¾ç¤º
                document.getElementById('currentScenario').textContent = data.scenario.name;
                
                // æ·»åŠ æˆ‘æ–¹æ— äººæœºæ ‡è®°
                let ourDroneCount = 0;
                data.scenario.our_drones.forEach((drone, index) => {
                    if (drone.lat && drone.lng) {
                        const lat = parseFloat(drone.lat);
                        const lng = parseFloat(drone.lng);
                        
        if (!isNaN(lat) && !isNaN(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
            const marker = L.marker([lat, lng], { 
                icon: getMarkerIcon('our_drone', 'our') 
            }).addTo(map);
            
            // æ‚¬åœæç¤ºï¼šæ˜¾ç¤ºæ— äººæœºç¼–å·åŠå½“å‰æ”»å‡»ç›®æ ‡
            const droneCodeLabel = drone.code || 'æœªè®¾ç½®';
            const initialTargetLabel = formatTargetLabel(null);
            const payload = formatPayloadSummary(drone);
            setMarkerTooltip(marker, `ç¼–å·ï¼š${droneCodeLabel}<br/>${payload}<br/>å½“å‰æ”»å‡»ç›®æ ‡ï¼š${initialTargetLabel}`);

            // ç‚¹å‡»é«˜äº®å½“å‰ç›®æ ‡å¹¶è¿çº¿
            marker.on('click', () => highlightTargetForDrone(marker));
            
            // ç»‘å®šåŠ¨æ€å¼¹å‡ºçª—å£ - ä½¿ç”¨ this æŒ‡å‘æ ‡è®°æœ¬èº«
            marker.bindPopup(function() {
                const currentPos = this.getLatLng();
                const droneData = this.droneData;
                                const targetLabel = formatTargetLabel(this.currentTarget);
                                return `
                                    <div style="min-width: 200px;">
                                        <h4 style="margin: 0 0 8px 0; color: #2c3e50;">æˆ‘æ–¹æ— äººæœº</h4>
                                        <p style="margin: 0 0 6px 0; color: #7f8c8d; font-size: 0.9rem;">
                                            <strong>ç¼–å·ï¼š</strong>${droneData.code || 'æœªè®¾ç½®'}
                                        </p>
                                        <p style="margin: 0 0 6px 0; color: #7f8c8d; font-size: 0.9rem;">
                                            <strong>é«˜åº¦ï¼š</strong>${droneData.altitude || 100}ç±³
                                        </p>
                                        <p style="margin: 0 0 6px 0; color: #7f8c8d; font-size: 0.9rem;">
                                            <strong>è½½è·ï¼š</strong>ç©ºåœ°å¯¼å¼¹${droneData.ar1 || 0}æš, ç©ºç©ºå¯¼å¼¹${droneData.pl10 || 0}æš, æœºç‚®${droneData.cannon || 0}é—¨
                                        </p>
                                        <p style="margin: 0 0 6px 0; color: #7f8c8d; font-size: 0.9rem;">
                                            <strong>æ”»å‡»ç›®æ ‡ï¼š</strong>${targetLabel}
                                        </p>
                                        <p style="margin: 0; color: #007bff; font-size: 0.8rem; font-family: monospace;">
                                            <strong>åæ ‡ï¼š</strong>${currentPos.lat.toFixed(4)}Â°N, ${currentPos.lng.toFixed(4)}Â°E
                                        </p>
                                    </div>
                                `;
                            });
                            
                            // å­˜å‚¨åŸå§‹æ•°æ®åˆ°æ ‡è®°å¯¹è±¡ä¸­
                            marker.droneData = drone;
                            marker.droneIndex = index;
                            
                            droneMarkers.push(marker);
                            ourDroneCount++;
                        }
                    }
                });
                
                // æ·»åŠ æ•Œæ–¹å•ä½æ ‡è®°
                let enemyUnitCount = 0;
                data.scenario.enemy_units.forEach((unit, index) => {
                    if (unit.lat && unit.lng) {
                        const lat = parseFloat(unit.lat);
                        const lng = parseFloat(unit.lng);
                        
                        if (!isNaN(lat) && !isNaN(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                            const marker = L.marker([lat, lng], { 
                                icon: getMarkerIcon(unit.type, 'enemy') 
                            }).addTo(map);
                            
                            // æ‚¬åœæç¤ºï¼šæ˜¾ç¤ºæ•Œæ–¹ç¼–å·
                            const unitCodeLabel = unit.code || 'æœªè®¾ç½®';
                            setMarkerTooltip(marker, `ç¼–å·ï¼š${unitCodeLabel}`);
                            
                            const typeNames = {
                                'reconnaissance_drone': 'ä¾¦å¯Ÿæ— äººæœº',
                                'attack_helicopter': 'æ­¦è£…ç›´å‡æœº',
                                'tank': 'å¦å…‹',
                                'armored_vehicle': 'è£…ç”²è½¦',
                                'military_base': 'å†›äº‹åŸºåœ°'
                            };
                            
                            // ç»‘å®šåŠ¨æ€å¼¹å‡ºçª—å£ - ä½¿ç”¨ this æŒ‡å‘æ ‡è®°æœ¬èº«
                            marker.bindPopup(function() {
                                const currentPos = this.getLatLng();
                                const unitData = this.unitData;
                                return `
                                    <div style="min-width: 200px;">
                                        <h4 style="margin: 0 0 8px 0; color: #dc3545;">${typeNames[unitData.type] || 'å•ä½'}</h4>
                                        <p style="margin: 0 0 6px 0; color: #7f8c8d; font-size: 0.9rem;">
                                            <strong>ç¼–å·ï¼š</strong>${unitData.code || 'æœªè®¾ç½®'}
                                        </p>
                                        ${unitData.altitude > 0 ? `<p style="margin: 0 0 6px 0; color: #7f8c8d; font-size: 0.9rem;">
                                            <strong>é«˜åº¦ï¼š</strong>${unitData.altitude}ç±³
                                        </p>` : ''}
                                        <p style="margin: 0; color: #dc3545; font-size: 0.8rem; font-family: monospace;">
                                            <strong>åæ ‡ï¼š</strong>${currentPos.lat.toFixed(4)}Â°N, ${currentPos.lng.toFixed(4)}Â°E
                                        </p>
                                    </div>
                                `;
                            });
                            
                            // å­˜å‚¨åŸå§‹æ•°æ®åˆ°æ ‡è®°å¯¹è±¡ä¸­
                            marker.unitData = unit;
                            marker.unitIndex = index;
                            
                            enemyMarkers.push(marker);
                            enemyUnitCount++;
                        }
                    }
                });
                
                // æ›´æ–°è®¡æ•°æ˜¾ç¤º
                document.getElementById('droneCount').textContent = ourDroneCount;
                document.getElementById('enemyCount').textContent = enemyUnitCount;
                updateStartButtonState();
                
                // è‡ªåŠ¨è°ƒæ•´åœ°å›¾è§†é‡ä»¥åŒ…å«æ‰€æœ‰æ ‡è®°
                if (droneMarkers.length > 0 || enemyMarkers.length > 0) {
                    const allMarkers = [...droneMarkers, ...enemyMarkers];
                    const group = new L.featureGroup(allMarkers);
                    map.fitBounds(group.getBounds().pad(0.1));
                }
                
                saveLog(`æˆåŠŸåŠ è½½åœºæ™¯ "${data.scenario.name}"ï¼Œæˆ‘æ–¹æ— äººæœº ${ourDroneCount} æ¶ï¼Œæ•Œæ–¹å•ä½ ${enemyUnitCount} ä¸ª`);
            } else {
                saveLog('åŠ è½½åœºæ™¯å¤±è´¥: ' + data.message, 'ERROR');
                alert('åŠ è½½åœºæ™¯å¤±è´¥: ' + data.message);
            }
        })
        .catch(error => {
            saveLog('è·å–åœºæ™¯æ•°æ®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'ERROR');
            alert('è·å–åœºæ™¯æ•°æ®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message);
        });
}

// ä»¿çœŸæ§åˆ¶åŠŸèƒ½
function startSimulation() {
    if (!isSimulationRunning && !isSimulationReady()) {
        alert('è¯·å…ˆé€‰æ‹©å¹¶åŠ è½½åœºæ™¯ï¼Œå¹¶é€‰æ‹©ç›®æ ‡åˆ†é…ä¸ç«åŠ›åˆ†é…æ¨¡å‹');
        return;
    }
    
    if (!isSimulationRunning) {
        // å¼€å§‹æ–°çš„ä»¿çœŸ
        isSimulationRunning = true;
        isPaused = false;
        clearTransientMessages();
        resetBattleStats();
        battleStats.startTime = Date.now();
        battleStats.initialEnemyCount = enemyMarkers.length;
        battleStats.initialDroneCount = droneMarkers.length;
        
        // åˆå§‹åŒ–è¿åŠ¨æ•°æ®
        initializeMovementData();
        
        // å¯åŠ¨ä»¿çœŸå¾ªç¯
        startSimulationLoop();
        
        // æ›´æ–°ç•Œé¢
        document.getElementById('simStatus').textContent = 'è¿è¡Œä¸­';
        document.getElementById('simStatus').className = 'status-badge running';
        document.getElementById('startSim').innerHTML = '<i class="fas fa-pause"></i> æš‚åœ';
        
        const targetName = selectedTargetModel ? selectedTargetModel.name : 'æœªé€‰æ‹©';
        const fireName = selectedFireModel ? selectedFireModel.name : 'æœªé€‰æ‹©';
        saveLog(`å¼€å§‹ä»¿çœŸï¼Œå½“å‰åœºæ™¯: ${currentScenarioData.name}ï¼Œç›®æ ‡åˆ†é…æ¨¡å‹: ${targetName}ï¼Œç«åŠ›åˆ†é…æ¨¡å‹: ${fireName}`);
        checkSimulationEnd();
    } else if (isPaused) {
        // ç»§ç»­ä»¿çœŸ
        isPaused = false;
        
        // é‡æ–°å¯åŠ¨ä»¿çœŸå¾ªç¯
        startSimulationLoop();
        
        // æ›´æ–°ç•Œé¢
        document.getElementById('simStatus').textContent = 'è¿è¡Œä¸­';
        document.getElementById('simStatus').className = 'status-badge running';
        document.getElementById('startSim').innerHTML = '<i class="fas fa-pause"></i> æš‚åœ';
        
        saveLog('ç»§ç»­ä»¿çœŸ');
    } else {
        // æš‚åœä»¿çœŸ
        isPaused = true;
        
        // åœæ­¢ä»¿çœŸå¾ªç¯
        stopSimulationLoop();
        
        // æ›´æ–°ç•Œé¢
        document.getElementById('simStatus').textContent = 'å·²æš‚åœ';
        document.getElementById('simStatus').className = 'status-badge paused';
        document.getElementById('startSim').innerHTML = '<i class="fas fa-play"></i> ç»§ç»­';
        
        saveLog('ä»¿çœŸæš‚åœ');
    }
}

function pauseSimulation() {
    // è¿™ä¸ªå‡½æ•°ä¿ç•™ä½†ä¸å†ä½¿ç”¨ï¼Œå› ä¸ºå·²ç»ç§»é™¤äº†æš‚åœæŒ‰é’®
    // æš‚åœåŠŸèƒ½ç°åœ¨é›†æˆåœ¨ startSimulation å‡½æ•°ä¸­
}

function stopSimulation() {
    // åœæ­¢ä»¿çœŸ
    isSimulationRunning = false;
    isPaused = false;
    
    // åœæ­¢ä»¿çœŸå¾ªç¯
    stopSimulationLoop();
    clearTransientMessages();
    hideBattleSummary();
    resetBattleStats();
    
    // é‡æ–°åŠ è½½åœºæ™¯ä»¥æ¢å¤åˆå§‹ä½ç½®
    if (currentScenarioData) {
        const scenarioSelect = document.getElementById('scenarioSelect');
        if (scenarioSelect.value) {
            loadScenarioToMap(scenarioSelect.value);
        }
    }
    
    // æ›´æ–°ç•Œé¢
    document.getElementById('simStatus').textContent = 'å°±ç»ª';
    document.getElementById('simStatus').className = 'status-badge';
    document.getElementById('startSim').innerHTML = '<i class="fas fa-play"></i> å¼€å§‹ä»¿çœŸ';
    updateStartButtonState();
    
    saveLog('ä»¿çœŸåœæ­¢ï¼Œå•ä½ä½ç½®å·²é‡ç½®');
}

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    // åˆå§‹åŒ–åœ°å›¾
    initMap();
    loadEnemyConfig();
    loadWeaponConfig();
    
    // åŠ è½½åœºæ™¯åˆ—è¡¨
    loadScenarios();
    // åŠ è½½æ¨¡å‹åˆ—è¡¨
    loadModels();
    showLoadScenarioButton();
    
    // ç»‘å®šæŒ‰é’®äº‹ä»¶
    document.getElementById('startSim').addEventListener('click', startSimulation);
    document.getElementById('stopSim').addEventListener('click', stopSimulation);
    
    // ç»‘å®šåŠ è½½åœºæ™¯æŒ‰é’®äº‹ä»¶
    document.getElementById('loadScenario').addEventListener('click', function() {
        const scenarioId = document.getElementById('scenarioSelect').value;
        if (scenarioId) {
            loadScenarioToMap(scenarioId);
        } else {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªåœºæ™¯');
        }
    });
    
    // ç»‘å®šæ¨¡å‹é€‰æ‹©äº‹ä»¶
    document.getElementById('targetModelSelect').addEventListener('change', function() {
        const modelId = parseInt(this.value, 10);
        selectedTargetModel = targetModels.find(model => model.id === modelId) || null;
        updateModelSelectionDisplay();
        updateStartButtonState();
    });

    document.getElementById('fireModelSelect').addEventListener('change', function() {
        const modelId = parseInt(this.value, 10);
        selectedFireModel = fireModels.find(model => model.id === modelId) || null;
        updateModelSelectionDisplay();
        updateStartButtonState();
    });
    
    const closeSummaryBtn = document.getElementById('closeSummary');
    if (closeSummaryBtn) {
        closeSummaryBtn.addEventListener('click', hideBattleSummary);
    }
    
    saveLog('ä»¿çœŸè¯„ä¼°é¡µé¢åˆå§‹åŒ–å®Œæˆ');
    updateStartButtonState();
});
</script>

{% endblock %}
