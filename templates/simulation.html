{% extends "base.html" %}

{% block title %}ä»¿çœŸè¯„ä¼° - æ— äººé›†ç¾¤æŒ‡æ§ç³»ç»Ÿ{% endblock %}

{% block page_title %}ä»¿çœŸè¯„ä¼°{% endblock %}

{% block content %}
<!-- Leaflet.js CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin="" />

<div class="simulation-container">
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <div class="panel-header">
            <h3><i class="fas fa-cogs"></i> ä»¿çœŸæ§åˆ¶</h3>
        </div>
        <div class="panel-content">
            <!-- åœºæ™¯é€‰æ‹©åŒºåŸŸ -->
            <div class="control-group scenario-selection">
                <label>é€‰æ‹©åœºæ™¯ï¼š</label>
                <select id="scenarioSelect" class="scenario-select">
                    <option value="">è¯·é€‰æ‹©åœºæ™¯...</option>
                </select>
                <button class="btn btn-info btn-sm" id="loadScenario">åŠ è½½åœºæ™¯</button>
            </div>

            <div class="model-select-block">
                <div class="model-select-header">
                    <span><i class="fas fa-robot"></i> æ¨¡å‹é€‰æ‹©</span>
                    <span class="required-flag">ä»¿çœŸå¿…é€‰ï¼šç›®æ ‡åˆ†é… + ç«åŠ›åˆ†é…</span>
                </div>
                <div class="model-select-grid">
                    <div class="model-select-item">
                        <label>ç›®æ ‡åˆ†é…æ¨¡å‹ï¼š</label>
                        <select id="targetModelSelect" class="model-select">
                            <option value="">æ­£åœ¨åŠ è½½...</option>
                        </select>
                        <div class="model-chip" id="targetModelStatus">æœªé€‰æ‹©</div>
                    </div>
                    <div class="model-select-item">
                        <label>ç«åŠ›åˆ†é…æ¨¡å‹ï¼š</label>
                        <select id="fireModelSelect" class="model-select">
                            <option value="">æ­£åœ¨åŠ è½½...</option>
                        </select>
                        <div class="model-chip" id="fireModelStatus">æœªé€‰æ‹©</div>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label>å½“å‰åœºæ™¯ï¼š</label>
                <span id="currentScenario">æœªé€‰æ‹©</span>
            </div>
            
            <div class="control-group">
                <label>ä»¿çœŸçŠ¶æ€ï¼š</label>
                <span class="status-badge" id="simStatus">å°±ç»ª</span>
            </div>
            <div class="control-group">
                <label>æˆ‘æ–¹æ— äººæœºï¼š</label>
                <span id="droneCount">0</span>
            </div>
            <div class="control-group">
                <label>æ•Œæ–¹å•ä½ï¼š</label>
                <span id="enemyCount">0</span>
            </div>
            <div class="control-group">
                <label>ä½œæˆ˜åŒºåŸŸï¼š</label>
                <span>å°æ¹¾æµ·å³¡</span>
            </div>
            <div class="control-group">
                <label>å¤©æ°”çŠ¶å†µï¼š</label>
                <span style="color: #28a745;">è‰¯å¥½</span>
            </div>
            <div class="control-group">
                <label>æµ·å†µç­‰çº§ï¼š</label>
                <span style="color: #007bff;">3çº§</span>
            </div>
            <div class="control-buttons">
                <button class="btn btn-primary" id="startSim">
                    <i class="fas fa-play"></i> å¼€å§‹ä»¿çœŸ
                </button>
                <button class="btn btn-danger" id="stopSim">
                    <i class="fas fa-stop"></i> åœæ­¢
                </button>
            </div>
            <div class="info-section">
                <h4>åœ°å›¾æ“ä½œè¯´æ˜ï¼š</h4>
                <ul>
                    <li>é¼ æ ‡æ‹–æ‹½ï¼šç§»åŠ¨åœ°å›¾</li>
                    <li>æ»šè½®ç¼©æ”¾ï¼šæ”¾å¤§/ç¼©å°åœ°å›¾</li>
                    <li>ç‚¹å‡»æ ‡è®°ï¼šæŸ¥çœ‹è¯¦ç»†ä¿¡æ¯</li>
                    <li>å›¾å±‚åˆ‡æ¢ï¼šä½¿ç”¨å³ä¸Šè§’æ§åˆ¶å™¨</li>
                </ul>
            </div>
            <div class="info-section">
                <h4>å›¾ä¾‹è¯´æ˜ï¼š</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 0.8rem;">
                    <div>âœˆï¸ æˆ‘æ–¹æ— äººæœº</div>
                    <div>ğŸ”´ æ•Œæ–¹å•ä½</div>
                    <div>ğŸš ä¾¦å¯Ÿæ— äººæœº</div>
                    <div>ğŸš æ­¦è£…ç›´å‡æœº</div>
                    <div>ğŸ’ª å¦å…‹</div>
                    <div>ğŸš— è£…ç”²è½¦</div>
                    <div>ğŸ¢ å†›äº‹åŸºåœ°</div>
                    <div>ğŸŒŠ æµ·åŸŸ</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- åœ°å›¾åŒºåŸŸ -->
    <div class="map-container">
        <div id="simulationMap" class="simulation-map"></div>
        
        <!-- åœ°å›¾ä¿¡æ¯æ˜¾ç¤º -->
        <div class="map-info" id="mapInfo">
            <div class="coords-info">
                <span>ç»åº¦ï¼š</span><span id="longitude">--</span>
                <span>çº¬åº¦ï¼š</span><span id="latitude">--</span>
                <span>ç¼©æ”¾çº§åˆ«ï¼š</span><span id="zoomLevel">--</span>
            </div>
        </div>
    </div>
</div>

<!-- æ·»åŠ æ ·å¼ -->
<style>
.scenario-selection {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 5px;
}

.scenario-select {
    flex: 1;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

.btn-info {
    background-color: #17a2b8;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

.btn-info:hover {
    background-color: #138496;
}

.btn-sm {
    padding: 6px 12px;
    font-size: 12px;
}

/* ä»¿çœŸçŠ¶æ€æ ·å¼ */
.status-badge {
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
    background-color: #6c757d;
    color: white;
}

.status-badge.running {
    background-color: #28a745;
    animation: pulse 2s infinite;
}

.status-badge.paused {
    background-color: #ffc107;
    color: #212529;
}

.control-panel .btn:disabled,
.control-panel .btn.disabled {
    cursor: not-allowed;
    opacity: 0.6;
    box-shadow: none;
}

.model-select-block {
    background: #f9fafb;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
}

.model-select-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    font-weight: 600;
    color: #1f2937;
}

.required-flag {
    font-size: 12px;
    color: #d97706;
    background: #fef3c7;
    border: 1px solid #fcd34d;
    padding: 3px 8px;
    border-radius: 999px;
}

.model-select-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
}

.model-select-item {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.model-select {
    padding: 8px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-size: 14px;
}

.model-select:disabled {
    background: #f3f4f6;
    cursor: not-allowed;
}

.model-chip {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 999px;
    background: #f3f4f6;
    color: #6b7280;
    font-size: 12px;
    border: 1px dashed #e5e7eb;
    max-width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.model-chip.active {
    background: #eef2ff;
    color: #4338ca;
    border-color: #c7d2fe;
}

.target-highlight {
    box-shadow: 0 0 0 4px rgba(255, 82, 82, 0.35), 0 0 12px rgba(255, 82, 82, 0.6);
    transform: scale(1.08);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}
</style>

<!-- Leaflet.js JavaScript -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>

<script>
// å…¨å±€å˜é‡
let map;
let droneMarkers = [];
let enemyMarkers = [];
let isSimulationRunning = false;
let isPaused = false;
let currentScenarioData = null;
let targetModels = [];
let fireModels = [];
let selectedTargetModel = null;
let selectedFireModel = null;
let simulationInterval = null;
let simulationSpeed = 1000; // ä»¿çœŸæ›´æ–°é—´éš”(æ¯«ç§’)
let activeHighlightLine = null;
let activeHighlightedTarget = null;
let activeHighlightedDrone = null;

// å•ä½è¿åŠ¨æ•°æ®
let unitMovementData = {
    ourDrones: [],
    enemyUnits: []
};

// å•ä½é€Ÿåº¦é…ç½® (km/h)
const UNIT_SPEEDS = {
    our_drone: 150, // æˆ‘æ–¹æ— äººæœºé€Ÿåº¦
    reconnaissance_drone: 120,
    attack_helicopter: 200,
    tank: 50,
    armored_vehicle: 80,
    military_base: 0 // åŸºåœ°ä¸ç§»åŠ¨
};

// æ—¥å¿—ä¿å­˜å‡½æ•°
function saveLog(message, level = 'INFO') {
    // åœ¨æ§åˆ¶å°æ˜¾ç¤ºæ—¥å¿—
    console.log(message);
    
    // æ£€æŸ¥æ¶ˆæ¯é•¿åº¦ï¼Œå¦‚æœå¤ªé•¿åˆ™æˆªæ–­
    let logMessage = message;
    if (logMessage.length > 2000) {
        logMessage = logMessage.substring(0, 1997) + '...';
        console.warn('æ—¥å¿—æ¶ˆæ¯è¿‡é•¿ï¼Œå·²æˆªæ–­è‡³ 2000 ä¸ªå­—ç¬¦');
    }
    
    // å‘é€æ—¥å¿—åˆ°åç«¯ä¿å­˜
    fetch('/api/save_log', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            message: logMessage,
            level: level
        })
    })
    .then(response => response.json())
    .then(data => {
        if (!data.success) {
            console.error('ä¿å­˜æ—¥å¿—å¤±è´¥:', data.message);
        }
    })
    .catch(error => {
        console.error('å‘é€æ—¥å¿—è¯·æ±‚å¤±è´¥:', error);
    });
}

// åˆå§‹åŒ–åœ°å›¾
function initMap() {
    // åˆ›å»ºåœ°å›¾å®ä¾‹ï¼ˆä»¥å°æ¹¾æµ·å³¡ä¸ºä¸­å¿ƒï¼‰
    // å°æ¹¾æµ·å³¡ä¸­å¿ƒä½ç½®ï¼šåŒ—çº¬24.5Â°ï¼Œä¸œç»120.0Â°
    map = L.map('simulationMap').setView([24.5, 120.0], 8);
    
    // å®šä¹‰å¤šç§åœ°å›¾å›¾å±‚
    const baseMaps = {
        'æ ‡å‡†åœ°å›¾': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 19
        }),
        
        'å«æ˜Ÿå›¾': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
            maxZoom: 19
        }),
        
        'åœ°å½¢å›¾': L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
            maxZoom: 17
        })
    };
    
    // é»˜è®¤ä½¿ç”¨å«æ˜Ÿå›¾ï¼ˆæ›´é€‚åˆæµ·ä¸Šä½œæˆ˜ï¼‰
    baseMaps['å«æ˜Ÿå›¾'].addTo(map);
    
    // æ·»åŠ å›¾å±‚æ§åˆ¶å™¨
    L.control.layers(baseMaps).addTo(map);
    
    // æ·»åŠ æ¯”ä¾‹å°ºæ§ä»¶
    L.control.scale().addTo(map);
    
    // ç›‘å¬åœ°å›¾äº‹ä»¶
    map.on('mousemove', function(e) {
        updateMapInfo(e.latlng.lat, e.latlng.lng, map.getZoom());
    });
    
    map.on('zoomend', function() {
        const center = map.getCenter();
        updateMapInfo(center.lat, center.lng, map.getZoom());
    });
    
    saveLog('å°æ¹¾æµ·å³¡åœ°å›¾åˆå§‹åŒ–å®Œæˆ');
}

// æ›´æ–°åœ°å›¾ä¿¡æ¯æ˜¾ç¤º
function updateMapInfo(lat, lng, zoom) {
    document.getElementById('latitude').textContent = lat.toFixed(6);
    document.getElementById('longitude').textContent = lng.toFixed(6);
    document.getElementById('zoomLevel').textContent = zoom;
}

// åŠ è½½åœºæ™¯åˆ—è¡¨
function loadScenarios() {
    fetch('/api/scenarios')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const select = document.getElementById('scenarioSelect');
                select.innerHTML = '<option value="">è¯·é€‰æ‹©åœºæ™¯...</option>';
                
                data.scenarios.forEach(scenario => {
                    const option = document.createElement('option');
                    option.value = scenario.id;
                    option.textContent = `${scenario.name} (æˆ‘æ–¹:${scenario.our_drone_count} æ•Œæ–¹:${scenario.enemy_total})`;
                    select.appendChild(option);
                });
                
                saveLog(`åŠ è½½äº† ${data.scenarios.length} ä¸ªåœºæ™¯åˆ°é€‰æ‹©åˆ—è¡¨`);
            } else {
                saveLog('åŠ è½½åœºæ™¯åˆ—è¡¨å¤±è´¥: ' + data.message, 'ERROR');
            }
        })
        .catch(error => {
            saveLog('è·å–åœºæ™¯åˆ—è¡¨æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'ERROR');
        });
}

// åŠ è½½æ¨¡å‹åˆ—è¡¨
function loadModels() {
    fetch('/api/models')
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                saveLog('åŠ è½½æ¨¡å‹åˆ—è¡¨å¤±è´¥: ' + data.message, 'ERROR');
                return;
            }
            targetModels = data.models.filter(model => model.category === 'target_allocation');
            fireModels = data.models.filter(model => model.category === 'fire_allocaltion');
            populateModelSelect('targetModelSelect', targetModels, 'è¯·é€‰æ‹©ç›®æ ‡åˆ†é…æ¨¡å‹...');
            populateModelSelect('fireModelSelect', fireModels, 'è¯·é€‰æ‹©ç«åŠ›åˆ†é…æ¨¡å‹...');
            updateModelSelectionDisplay();
            updateStartButtonState();
            saveLog(`åŠ è½½æ¨¡å‹åˆ—è¡¨æˆåŠŸï¼šç›®æ ‡åˆ†é… ${targetModels.length} ä¸ªï¼Œç«åŠ›åˆ†é… ${fireModels.length} ä¸ª`);
        })
        .catch(error => {
            saveLog('è·å–æ¨¡å‹åˆ—è¡¨æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'ERROR');
        });
}

// å¡«å……æ¨¡å‹ä¸‹æ‹‰æ¡†
function populateModelSelect(selectId, models, placeholder) {
    const select = document.getElementById(selectId);
    if (!select) return;

    select.innerHTML = '';
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = models.length ? placeholder : 'æš‚æ— å¯ç”¨æ¨¡å‹';
    select.appendChild(defaultOption);

    models.forEach(model => {
        const option = document.createElement('option');
        option.value = model.id;
        option.textContent = `${model.name}${model.version ? ' Â· ' + model.version : ''}`;
        select.appendChild(option);
    });

    select.disabled = models.length === 0;
}

// æ›´æ–°æ¨¡å‹é€‰æ‹©çŠ¶æ€å±•ç¤º
function updateModelSelectionDisplay() {
    const targetStatus = document.getElementById('targetModelStatus');
    const fireStatus = document.getElementById('fireModelStatus');

    if (targetStatus) {
        if (selectedTargetModel) {
            targetStatus.textContent = `${selectedTargetModel.name}${selectedTargetModel.version ? ' Â· ' + selectedTargetModel.version : ''}`;
            targetStatus.classList.add('active');
        } else {
            targetStatus.textContent = 'æœªé€‰æ‹©';
            targetStatus.classList.remove('active');
        }
    }

    if (fireStatus) {
        if (selectedFireModel) {
            fireStatus.textContent = `${selectedFireModel.name}${selectedFireModel.version ? ' Â· ' + selectedFireModel.version : ''}`;
            fireStatus.classList.add('active');
        } else {
            fireStatus.textContent = 'æœªé€‰æ‹©';
            fireStatus.classList.remove('active');
        }
    }
}

// æ£€æŸ¥ä»¿çœŸæ˜¯å¦å¯ä»¥å¯åŠ¨
function isSimulationReady() {
    return Boolean(currentScenarioData && selectedTargetModel && selectedFireModel);
}

function updateStartButtonState() {
    const startBtn = document.getElementById('startSim');
    if (!startBtn) return;
    const canStart = isSimulationReady() || isSimulationRunning;
    startBtn.disabled = !canStart;
    if (startBtn.disabled) {
        startBtn.classList.add('disabled');
        startBtn.title = 'è¯·é€‰æ‹©åœºæ™¯ï¼Œå¹¶é€‰æ‹©ç›®æ ‡åˆ†é…/ç«åŠ›åˆ†é…æ¨¡å‹åå†å¼€å§‹';
    } else {
        startBtn.classList.remove('disabled');
        startBtn.title = '';
    }
}

// æ¸…é™¤åœ°å›¾ä¸Šçš„æ‰€æœ‰æ ‡è®°
function clearMapMarkers() {
    // æ¸…é™¤æˆ‘æ–¹æ— äººæœºæ ‡è®°
    droneMarkers.forEach(marker => {
        map.removeLayer(marker);
    });
    droneMarkers = [];
    
    // æ¸…é™¤æ•Œæ–¹å•ä½æ ‡è®°
    enemyMarkers.forEach(marker => {
        map.removeLayer(marker);
    });
    enemyMarkers = [];
    
    clearTargetHighlight();
    saveLog('æ¸…é™¤åœ°å›¾ä¸Šçš„æ‰€æœ‰æ ‡è®°');
}

// è·å–æ ‡è®°å›¾æ ‡
function getMarkerIcon(type, side = 'enemy') {
    const icons = {
        // æˆ‘æ–¹æ— äººæœº
        our_drone: 'âœˆï¸',
        
        // æ•Œæ–¹å•ä½
        reconnaissance_drone: 'ğŸš',
        attack_helicopter: 'ğŸš', 
        tank: 'ğŸ†',
        armored_vehicle: 'ğŸš—',
        military_base: 'ğŸ¢'
    };
    
    const colors = {
        our_drone: '#007bff',
        reconnaissance_drone: '#dc3545',
        attack_helicopter: '#dc3545',
        tank: '#dc3545',
        armored_vehicle: '#dc3545',
        military_base: '#dc3545'
    };
    
    const iconKey = side === 'our' ? 'our_drone' : type;
    
    return L.divIcon({
        html: `<div style="
            font-size: 20px; 
            text-align: center; 
            line-height: 1;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));
            background: ${colors[iconKey] || '#6c757d'};
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
        ">${icons[iconKey] || 'âœˆï¸'}</div>`,
        className: 'custom-marker',
        iconSize: [32, 32],
        iconAnchor: [16, 16]
    });
}

// ç”Ÿæˆéšæœºç›®æ ‡ä½ç½®
function generateRandomTarget(currentLat, currentLng, maxDistance = 0.1) {
    // ç”Ÿæˆéšæœºæ–¹å‘å’Œè·ç¦»
    const angle = Math.random() * 2 * Math.PI;
    const distance = Math.random() * maxDistance;
    
    // è®¡ç®—æ–°çš„ç»çº¬åº¦
    const newLat = currentLat + (distance * Math.cos(angle));
    const newLng = currentLng + (distance * Math.sin(angle));
    
    return { lat: newLat, lng: newLng };
}

// è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦» (å…¬é‡Œ)
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371; // åœ°çƒåŠå¾„ï¼ˆå…¬é‡Œï¼‰
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

function setMarkerTooltip(marker, content) {
    const existingTooltip = marker.getTooltip ? marker.getTooltip() : null;
    if (existingTooltip) {
        if (marker.setTooltipContent) {
            marker.setTooltipContent(content);
        } else if (existingTooltip.setContent) {
            existingTooltip.setContent(content);
        }
    } else {
        marker.bindTooltip(content, {
            direction: 'top',
            opacity: 0.9,
            offset: [0, -4]
        });
    }
}

function formatTargetLabel(targetMarker) {
    if (!targetMarker) {
        return 'æœªåˆ†é…';
    }
    const unitData = targetMarker.unitData || {};
    return unitData.code || 'æœªè®¾ç½®';
}

function formatPayloadSummary(droneData = {}) {
    const radar = droneData.radar || 0;
    const hq9b = droneData.hq9b || 0;
    const pl10 = droneData.pl10 || 0;
    const cannon = droneData.cannon || 0;
    return `è½½è·ï¼šé›·è¾¾:${radar} HQ9B:${hq9b} PL-10:${pl10} æœºç‚®:${cannon}`;
}

function updateDroneTooltip(unit) {
    const label = formatTargetLabel(unit.targetMarker);
    const codeLabel = unit.data && unit.data.code ? unit.data.code : 'æœªè®¾ç½®';
    const payload = formatPayloadSummary(unit.data || {});
    const content = `ç¼–å·ï¼š${codeLabel}<br/>${payload}<br/>å½“å‰æ”»å‡»ç›®æ ‡ï¼š${label}`;
    setMarkerTooltip(unit.marker, content);
    unit.marker.currentTarget = unit.targetMarker;
}

function clearTargetHighlight() {
    if (activeHighlightLine) {
        map.removeLayer(activeHighlightLine);
        activeHighlightLine = null;
    }
    if (activeHighlightedTarget && activeHighlightedTarget._icon) {
        activeHighlightedTarget._icon.classList.remove('target-highlight');
    }
    activeHighlightedTarget = null;
    activeHighlightedDrone = null;
}

function highlightTargetForDrone(droneMarker) {
    const unit = unitMovementData.ourDrones.find(u => u.marker === droneMarker);
    const targetMarker = (unit && unit.targetMarker) || droneMarker.currentTarget;
    // å¦‚æœå½“å‰å°±æ˜¯é€‰ä¸­çš„æ— äººæœºï¼Œåˆ‡æ¢ä¸ºå–æ¶ˆé«˜äº®
    if (activeHighlightedDrone === droneMarker) {
        clearTargetHighlight();
        return;
    }

    clearTargetHighlight();
    if (!targetMarker) {
        return;
    }
    activeHighlightedTarget = targetMarker;
    activeHighlightedDrone = droneMarker;
    if (targetMarker._icon) {
        targetMarker._icon.classList.add('target-highlight');
    }
    activeHighlightLine = L.polyline(
        [droneMarker.getLatLng(), targetMarker.getLatLng()],
        { color: '#ff5252', weight: 3, dashArray: '8,4', opacity: 0.8 }
    ).addTo(map);
    if (targetMarker.bringToFront) targetMarker.bringToFront();
    if (droneMarker.bringToFront) droneMarker.bringToFront();
}

// ä¸ºæˆ‘æ–¹æ— äººæœºéšæœºæŒ‘é€‰ä¸€ä¸ªæ•Œæ–¹ç›®æ ‡
function pickRandomEnemyTarget() {
    if (!enemyMarkers.length) {
        return null;
    }
    const randomIndex = Math.floor(Math.random() * enemyMarkers.length);
    return enemyMarkers[randomIndex];
}

// åˆå§‹åŒ–å•ä½è¿åŠ¨æ•°æ®
function initializeMovementData() {
    unitMovementData.ourDrones = [];
    unitMovementData.enemyUnits = [];
    
    // åˆå§‹åŒ–æˆ‘æ–¹æ— äººæœºè¿åŠ¨æ•°æ®
    droneMarkers.forEach((marker, index) => {
        const currentPos = marker.getLatLng();
        const targetMarker = pickRandomEnemyTarget();
        const target = targetMarker ? targetMarker.getLatLng() : generateRandomTarget(currentPos.lat, currentPos.lng, 0.2);
        
        unitMovementData.ourDrones.push({
            marker: marker,
            currentPos: currentPos,
            targetPos: target,
            targetMarker: targetMarker,
            speed: UNIT_SPEEDS.our_drone,
            data: currentScenarioData.our_drones[index] || {},
            isOur: true
        });
        marker.currentTarget = targetMarker;
        updateDroneTooltip(unitMovementData.ourDrones[unitMovementData.ourDrones.length - 1]);
    });
    
    // åˆå§‹åŒ–æ•Œæ–¹å•ä½è¿åŠ¨æ•°æ®
    enemyMarkers.forEach((marker, index) => {
        const currentPos = marker.getLatLng();
        const unitData = currentScenarioData.enemy_units[index] || {};
        const unitType = unitData.type || 'reconnaissance_drone';
        
        // åŸºåœ°ä¸ç§»åŠ¨
        if (unitType === 'military_base') {
            return;
        }
        
        const target = generateRandomTarget(currentPos.lat, currentPos.lng, 0.15);
        
        unitMovementData.enemyUnits.push({
            marker: marker,
            currentPos: currentPos,
            targetPos: target,
            speed: UNIT_SPEEDS[unitType] || 100,
            type: unitType,
            data: unitData,
            isOur: false
        });
    });
    
    saveLog(`åˆå§‹åŒ–è¿åŠ¨æ•°æ®ï¼šæˆ‘æ–¹æ— äººæœº ${unitMovementData.ourDrones.length} æ¶ï¼Œæ•Œæ–¹ç§»åŠ¨å•ä½ ${unitMovementData.enemyUnits.length} ä¸ª`);
}

// æ›´æ–°å•ä½ä½ç½®
function updateUnitPositions() {
    if (!isSimulationRunning || isPaused) return;
    
    const updateInterval = simulationSpeed / 1000; // è½¬æ¢ä¸ºç§’
    
    // æ›´æ–°æˆ‘æ–¹æ— äººæœºä½ç½®
    unitMovementData.ourDrones.forEach(unit => {
        // æˆ‘æ–¹æ— äººæœºå§‹ç»ˆè¿½è¸ªç›®æ ‡æ ‡è®°çš„å®æ—¶ä½ç½®
        if (unit.targetMarker) {
            unit.targetPos = unit.targetMarker.getLatLng();
        }
        moveUnitTowardsTarget(unit, updateInterval);
    });
    
    // æ›´æ–°æ•Œæ–¹å•ä½ä½ç½®
    unitMovementData.enemyUnits.forEach(unit => {
        moveUnitTowardsTarget(unit, updateInterval);
    });

    // å¦‚æœæœ‰é«˜äº®è¿çº¿ï¼Œåˆ·æ–°ä½ç½®
    if (activeHighlightLine && activeHighlightedDrone && activeHighlightedTarget) {
        activeHighlightLine.setLatLngs([
            activeHighlightedDrone.getLatLng(),
            activeHighlightedTarget.getLatLng()
        ]);
    }
}

// ç§»åŠ¨å•ä½æœå‘ç›®æ ‡
function moveUnitTowardsTarget(unit, timeStep) {
    const { marker, currentPos, targetPos, speed } = unit;
    
    // è®¡ç®—è·ç¦»ç›®æ ‡çš„è·ç¦»
    const distanceToTarget = calculateDistance(
        currentPos.lat, currentPos.lng,
        targetPos.lat, targetPos.lng
    );
    
    // å¦‚æœå·²ç»æ¥è¿‘ç›®æ ‡ï¼Œç”Ÿæˆæ–°ç›®æ ‡
    if (distanceToTarget < 0.01) {
        if (unit.isOur) {
            // æˆ‘æ–¹æ— äººæœºåˆ°è¾¾åé‡æ–°éšæœºåˆ†é…æ–°çš„æ•Œæ–¹ç›®æ ‡
            const newTargetMarker = pickRandomEnemyTarget();
            unit.targetMarker = newTargetMarker;
            if (newTargetMarker) {
                unit.targetPos = newTargetMarker.getLatLng();
            } else {
                unit.targetPos = generateRandomTarget(currentPos.lat, currentPos.lng, 0.2);
            }
            updateDroneTooltip(unit);
        } else {
            unit.targetPos = generateRandomTarget(currentPos.lat, currentPos.lng, 0.2);
        }
        return;
    }
    
    // è®¡ç®—ç§»åŠ¨è·ç¦»ï¼ˆé€Ÿåº¦ * æ—¶é—´ï¼‰
    const moveDistance = (speed * timeStep) / 3600; // è½¬æ¢ä¸ºå…¬é‡Œ
    
    // è®¡ç®—ç§»åŠ¨æ–¹å‘
    const bearing = Math.atan2(
        targetPos.lng - currentPos.lng,
        targetPos.lat - currentPos.lat
    );
    
    // è®¡ç®—æ–°ä½ç½®
    const moveRatio = Math.min(moveDistance / distanceToTarget, 1);
    const newLat = currentPos.lat + (targetPos.lat - currentPos.lat) * moveRatio;
    const newLng = currentPos.lng + (targetPos.lng - currentPos.lng) * moveRatio;
    
    // æ›´æ–°æ ‡è®°ä½ç½®
    const newPos = L.latLng(newLat, newLng);
    marker.setLatLng(newPos);
    unit.currentPos = newPos;
}

// å¼€å§‹ä»¿çœŸå¾ªç¯
function startSimulationLoop() {
    if (simulationInterval) {
        clearInterval(simulationInterval);
    }
    
    simulationInterval = setInterval(updateUnitPositions, simulationSpeed);
    saveLog('ä»¿çœŸå¾ªç¯å·²å¯åŠ¨');
}

// åœæ­¢ä»¿çœŸå¾ªç¯
function stopSimulationLoop() {
    if (simulationInterval) {
        clearInterval(simulationInterval);
        simulationInterval = null;
        saveLog('ä»¿çœŸå¾ªç¯å·²åœæ­¢');
    }
}

// åŠ è½½åœºæ™¯æ•°æ®åˆ°åœ°å›¾
function loadScenarioToMap(scenarioId) {
    fetch(`/api/scenario/${scenarioId}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                currentScenarioData = data.scenario;
                
                // æ¸…é™¤ç°æœ‰æ ‡è®°
                clearMapMarkers();
                
                // æ›´æ–°åœºæ™¯ä¿¡æ¯æ˜¾ç¤º
                document.getElementById('currentScenario').textContent = data.scenario.name;
                
                // æ·»åŠ æˆ‘æ–¹æ— äººæœºæ ‡è®°
                let ourDroneCount = 0;
                data.scenario.our_drones.forEach((drone, index) => {
                    if (drone.lat && drone.lng) {
                        const lat = parseFloat(drone.lat);
                        const lng = parseFloat(drone.lng);
                        
        if (!isNaN(lat) && !isNaN(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
            const marker = L.marker([lat, lng], { 
                icon: getMarkerIcon('our_drone', 'our') 
            }).addTo(map);
            
            // æ‚¬åœæç¤ºï¼šæ˜¾ç¤ºæ— äººæœºç¼–å·åŠå½“å‰æ”»å‡»ç›®æ ‡
            const droneCodeLabel = drone.code || 'æœªè®¾ç½®';
            const initialTargetLabel = formatTargetLabel(null);
            const payload = formatPayloadSummary(drone);
            setMarkerTooltip(marker, `ç¼–å·ï¼š${droneCodeLabel}<br/>${payload}<br/>å½“å‰æ”»å‡»ç›®æ ‡ï¼š${initialTargetLabel}`);

            // ç‚¹å‡»é«˜äº®å½“å‰ç›®æ ‡å¹¶è¿çº¿
            marker.on('click', () => highlightTargetForDrone(marker));
            
            // ç»‘å®šåŠ¨æ€å¼¹å‡ºçª—å£ - ä½¿ç”¨ this æŒ‡å‘æ ‡è®°æœ¬èº«
            marker.bindPopup(function() {
                const currentPos = this.getLatLng();
                const droneData = this.droneData;
                                const targetLabel = formatTargetLabel(this.currentTarget);
                                return `
                                    <div style="min-width: 200px;">
                                        <h4 style="margin: 0 0 8px 0; color: #2c3e50;">æˆ‘æ–¹æ— äººæœº</h4>
                                        <p style="margin: 0 0 6px 0; color: #7f8c8d; font-size: 0.9rem;">
                                            <strong>ç¼–å·ï¼š</strong>${droneData.code || 'æœªè®¾ç½®'}
                                        </p>
                                        <p style="margin: 0 0 6px 0; color: #7f8c8d; font-size: 0.9rem;">
                                            <strong>é«˜åº¦ï¼š</strong>${droneData.altitude || 100}ç±³
                                        </p>
                                        <p style="margin: 0 0 6px 0; color: #7f8c8d; font-size: 0.9rem;">
                                            <strong>è½½è·ï¼š</strong>é›·è¾¾${droneData.radar || 0}ä¸ª, HQ9B${droneData.hq9b || 0}ä¸ª, PL-10${droneData.pl10 || 0}ä¸ª, æœºç‚®${droneData.cannon || 0}é—¨
                                        </p>
                                        <p style="margin: 0 0 6px 0; color: #7f8c8d; font-size: 0.9rem;">
                                            <strong>æ”»å‡»ç›®æ ‡ï¼š</strong>${targetLabel}
                                        </p>
                                        <p style="margin: 0; color: #007bff; font-size: 0.8rem; font-family: monospace;">
                                            <strong>åæ ‡ï¼š</strong>${currentPos.lat.toFixed(4)}Â°N, ${currentPos.lng.toFixed(4)}Â°E
                                        </p>
                                    </div>
                                `;
                            });
                            
                            // å­˜å‚¨åŸå§‹æ•°æ®åˆ°æ ‡è®°å¯¹è±¡ä¸­
                            marker.droneData = drone;
                            marker.droneIndex = index;
                            
                            droneMarkers.push(marker);
                            ourDroneCount++;
                        }
                    }
                });
                
                // æ·»åŠ æ•Œæ–¹å•ä½æ ‡è®°
                let enemyUnitCount = 0;
                data.scenario.enemy_units.forEach((unit, index) => {
                    if (unit.lat && unit.lng) {
                        const lat = parseFloat(unit.lat);
                        const lng = parseFloat(unit.lng);
                        
                        if (!isNaN(lat) && !isNaN(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                            const marker = L.marker([lat, lng], { 
                                icon: getMarkerIcon(unit.type, 'enemy') 
                            }).addTo(map);
                            
                            // æ‚¬åœæç¤ºï¼šæ˜¾ç¤ºæ•Œæ–¹ç¼–å·
                            const unitCodeLabel = unit.code || 'æœªè®¾ç½®';
                            setMarkerTooltip(marker, `ç¼–å·ï¼š${unitCodeLabel}`);
                            
                            const typeNames = {
                                'reconnaissance_drone': 'ä¾¦å¯Ÿæ— äººæœº',
                                'attack_helicopter': 'æ­¦è£…ç›´å‡æœº',
                                'tank': 'å¦å…‹',
                                'armored_vehicle': 'è£…ç”²è½¦',
                                'military_base': 'å†›äº‹åŸºåœ°'
                            };
                            
                            // ç»‘å®šåŠ¨æ€å¼¹å‡ºçª—å£ - ä½¿ç”¨ this æŒ‡å‘æ ‡è®°æœ¬èº«
                            marker.bindPopup(function() {
                                const currentPos = this.getLatLng();
                                const unitData = this.unitData;
                                return `
                                    <div style="min-width: 200px;">
                                        <h4 style="margin: 0 0 8px 0; color: #dc3545;">${typeNames[unitData.type] || 'å•ä½'}</h4>
                                        <p style="margin: 0 0 6px 0; color: #7f8c8d; font-size: 0.9rem;">
                                            <strong>ç¼–å·ï¼š</strong>${unitData.code || 'æœªè®¾ç½®'}
                                        </p>
                                        ${unitData.altitude > 0 ? `<p style="margin: 0 0 6px 0; color: #7f8c8d; font-size: 0.9rem;">
                                            <strong>é«˜åº¦ï¼š</strong>${unitData.altitude}ç±³
                                        </p>` : ''}
                                        <p style="margin: 0; color: #dc3545; font-size: 0.8rem; font-family: monospace;">
                                            <strong>åæ ‡ï¼š</strong>${currentPos.lat.toFixed(4)}Â°N, ${currentPos.lng.toFixed(4)}Â°E
                                        </p>
                                    </div>
                                `;
                            });
                            
                            // å­˜å‚¨åŸå§‹æ•°æ®åˆ°æ ‡è®°å¯¹è±¡ä¸­
                            marker.unitData = unit;
                            marker.unitIndex = index;
                            
                            enemyMarkers.push(marker);
                            enemyUnitCount++;
                        }
                    }
                });
                
                // æ›´æ–°è®¡æ•°æ˜¾ç¤º
                document.getElementById('droneCount').textContent = ourDroneCount;
                document.getElementById('enemyCount').textContent = enemyUnitCount;
                updateStartButtonState();
                
                // è‡ªåŠ¨è°ƒæ•´åœ°å›¾è§†é‡ä»¥åŒ…å«æ‰€æœ‰æ ‡è®°
                if (droneMarkers.length > 0 || enemyMarkers.length > 0) {
                    const allMarkers = [...droneMarkers, ...enemyMarkers];
                    const group = new L.featureGroup(allMarkers);
                    map.fitBounds(group.getBounds().pad(0.1));
                }
                
                saveLog(`æˆåŠŸåŠ è½½åœºæ™¯ "${data.scenario.name}"ï¼Œæˆ‘æ–¹æ— äººæœº ${ourDroneCount} æ¶ï¼Œæ•Œæ–¹å•ä½ ${enemyUnitCount} ä¸ª`);
            } else {
                saveLog('åŠ è½½åœºæ™¯å¤±è´¥: ' + data.message, 'ERROR');
                alert('åŠ è½½åœºæ™¯å¤±è´¥: ' + data.message);
            }
        })
        .catch(error => {
            saveLog('è·å–åœºæ™¯æ•°æ®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'ERROR');
            alert('è·å–åœºæ™¯æ•°æ®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message);
        });
}

// ä»¿çœŸæ§åˆ¶åŠŸèƒ½
function startSimulation() {
    if (!isSimulationRunning && !isSimulationReady()) {
        alert('è¯·å…ˆé€‰æ‹©å¹¶åŠ è½½åœºæ™¯ï¼Œå¹¶é€‰æ‹©ç›®æ ‡åˆ†é…ä¸ç«åŠ›åˆ†é…æ¨¡å‹');
        return;
    }
    
    if (!isSimulationRunning) {
        // å¼€å§‹æ–°çš„ä»¿çœŸ
        isSimulationRunning = true;
        isPaused = false;
        
        // åˆå§‹åŒ–è¿åŠ¨æ•°æ®
        initializeMovementData();
        
        // å¯åŠ¨ä»¿çœŸå¾ªç¯
        startSimulationLoop();
        
        // æ›´æ–°ç•Œé¢
        document.getElementById('simStatus').textContent = 'è¿è¡Œä¸­';
        document.getElementById('simStatus').className = 'status-badge running';
        document.getElementById('startSim').innerHTML = '<i class="fas fa-pause"></i> æš‚åœ';
        
        const targetName = selectedTargetModel ? selectedTargetModel.name : 'æœªé€‰æ‹©';
        const fireName = selectedFireModel ? selectedFireModel.name : 'æœªé€‰æ‹©';
        saveLog(`å¼€å§‹ä»¿çœŸï¼Œå½“å‰åœºæ™¯: ${currentScenarioData.name}ï¼Œç›®æ ‡åˆ†é…æ¨¡å‹: ${targetName}ï¼Œç«åŠ›åˆ†é…æ¨¡å‹: ${fireName}`);
    } else if (isPaused) {
        // ç»§ç»­ä»¿çœŸ
        isPaused = false;
        
        // é‡æ–°å¯åŠ¨ä»¿çœŸå¾ªç¯
        startSimulationLoop();
        
        // æ›´æ–°ç•Œé¢
        document.getElementById('simStatus').textContent = 'è¿è¡Œä¸­';
        document.getElementById('simStatus').className = 'status-badge running';
        document.getElementById('startSim').innerHTML = '<i class="fas fa-pause"></i> æš‚åœ';
        
        saveLog('ç»§ç»­ä»¿çœŸ');
    } else {
        // æš‚åœä»¿çœŸ
        isPaused = true;
        
        // åœæ­¢ä»¿çœŸå¾ªç¯
        stopSimulationLoop();
        
        // æ›´æ–°ç•Œé¢
        document.getElementById('simStatus').textContent = 'å·²æš‚åœ';
        document.getElementById('simStatus').className = 'status-badge paused';
        document.getElementById('startSim').innerHTML = '<i class="fas fa-play"></i> ç»§ç»­';
        
        saveLog('ä»¿çœŸæš‚åœ');
    }
}

function pauseSimulation() {
    // è¿™ä¸ªå‡½æ•°ä¿ç•™ä½†ä¸å†ä½¿ç”¨ï¼Œå› ä¸ºå·²ç»ç§»é™¤äº†æš‚åœæŒ‰é’®
    // æš‚åœåŠŸèƒ½ç°åœ¨é›†æˆåœ¨ startSimulation å‡½æ•°ä¸­
}

function stopSimulation() {
    // åœæ­¢ä»¿çœŸ
    isSimulationRunning = false;
    isPaused = false;
    
    // åœæ­¢ä»¿çœŸå¾ªç¯
    stopSimulationLoop();
    
    // é‡æ–°åŠ è½½åœºæ™¯ä»¥æ¢å¤åˆå§‹ä½ç½®
    if (currentScenarioData) {
        const scenarioSelect = document.getElementById('scenarioSelect');
        if (scenarioSelect.value) {
            loadScenarioToMap(scenarioSelect.value);
        }
    }
    
    // æ›´æ–°ç•Œé¢
    document.getElementById('simStatus').textContent = 'å°±ç»ª';
    document.getElementById('simStatus').className = 'status-badge';
    document.getElementById('startSim').innerHTML = '<i class="fas fa-play"></i> å¼€å§‹ä»¿çœŸ';
    updateStartButtonState();
    
    saveLog('ä»¿çœŸåœæ­¢ï¼Œå•ä½ä½ç½®å·²é‡ç½®');
}

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    // åˆå§‹åŒ–åœ°å›¾
    initMap();
    
    // åŠ è½½åœºæ™¯åˆ—è¡¨
    loadScenarios();
    // åŠ è½½æ¨¡å‹åˆ—è¡¨
    loadModels();
    
    // ç»‘å®šæŒ‰é’®äº‹ä»¶
    document.getElementById('startSim').addEventListener('click', startSimulation);
    document.getElementById('stopSim').addEventListener('click', stopSimulation);
    
    // ç»‘å®šåŠ è½½åœºæ™¯æŒ‰é’®äº‹ä»¶
    document.getElementById('loadScenario').addEventListener('click', function() {
        const scenarioId = document.getElementById('scenarioSelect').value;
        if (scenarioId) {
            loadScenarioToMap(scenarioId);
        } else {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªåœºæ™¯');
        }
    });
    
    // ç»‘å®šæ¨¡å‹é€‰æ‹©äº‹ä»¶
    document.getElementById('targetModelSelect').addEventListener('change', function() {
        const modelId = parseInt(this.value, 10);
        selectedTargetModel = targetModels.find(model => model.id === modelId) || null;
        updateModelSelectionDisplay();
        updateStartButtonState();
    });

    document.getElementById('fireModelSelect').addEventListener('change', function() {
        const modelId = parseInt(this.value, 10);
        selectedFireModel = fireModels.find(model => model.id === modelId) || null;
        updateModelSelectionDisplay();
        updateStartButtonState();
    });
    
    saveLog('ä»¿çœŸè¯„ä¼°é¡µé¢åˆå§‹åŒ–å®Œæˆ');
    updateStartButtonState();
});
</script>

{% endblock %}
